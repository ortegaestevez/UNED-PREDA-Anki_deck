#separator:tab
#html:true
"¿Cuál de las siguientes afirmaciones es falsa? <ol type=""a""><li>El algoritmo de ordenación basada en montículos (heapsort) es \(O(n \log n)\).</li><li style=""text-align: justify;"">La eficiencia del algoritmo de ordenación rápida (quicksort) es independiente de que el pivote sea el elemento de menor valor del vector.</li><li>El algoritmo de ordenación por fusión (mergesort) es \(O(n \log n)\).</li><li>El algoritmo de ordenación rápida en el caso peor es \(O(n^{2})\).</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr><ol type=""a""><li>Cierta.</li><li>Falsa. El coste si depende de si el pivote es el menor elemento de valor menor.</li><li>Cierta.</li><li>Cierta.</li></ol></div>"
"Indique cuál de las siguientes afirmaciones es cierta:<ol type=""a""><li>El esquema de divide y vencerás obtiene siempre soluciones eficientes de coste \(O(\log n)\) o \(O(n \log n)\)</li><li>La búsqueda en profundidad recursiva obtiene siempre una eficiencia logarítmica</li><li>La ordenación por Quicksort tiene coste \(O(n^{2})\) en el caso peor</li><li>Ninguna de las otras opciones es cierta.</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><ol type=""a""><li>Falsa.</li><li>Falsa. En el peor caso es lineal.</li><li>Cierta.</li><li>Falsa, es la \(c\).</li></div>"
"<div style=""text-align: justify;"">Indica de entre los siguientes, cuál sería el coste mínimo de un algoritmo que dado un vector&nbsp;\(C[1..n]\) de números enteros distintos no ordenado, y un entero \(S\), determine si existen o no dos elementos de \(C\) tales que su suma sea exactamente \(S\).</div><br><ol type=""a""><li>\(\Theta(n \log n)\)</li><li>\(\Theta(n)\)</li><li>\(\Theta(n^{2})\)</li><li>\(\Theta(n^{2} \log n)\)</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr>Teóricamente sería la&nbsp;\(b\): se puede utilizar un hash set para almacenar los elementos de&nbsp;\(C\)&nbsp;y verificar si el complemento de cada elemento, es decir&nbsp;\(S-C[i]\), ya está en el hash set. Este método requiere un recorrido lineal por el vector y una búsqueda en tiempo constante para cada elemento. Sin embargo, parece una pregunta que no va en consonancia con lo visto en la asignatura, ya que en el texto base no hay algoritmos en los que se usen hash sets. Entonces se marcaría la respuesta&nbsp;\(c\); que implica recorrer todo el espacio de búsqueda.</div>"
"¿Cuál de las siguientes afirmaciones es falsa con respecto al coste de las funciones de manipulación de grafos?<ol type=""a""><li>La función Etiqueta que devuelve la etiqueta o peso asociado a la arista que une dos vértices tiene un coste constante cuando el grafo se implementa con una matriz de adyacencia.</li><li>La función BorrarArista es más costosa cuando el grafo se implementa mediante una lista de adyacencia.</li><li>La operación Adyacente?, que comprueba si dos nodos son adyacentes, es más costosa cuando el grafo se implementa con una matriz de adyacencia.</li><li>La función Adyacentes, que devuelve una lista con los vértices adyacentes a uno dado, es menos costosa cuando el grafo se implementa con una matriz de adyacencia.</li></ol>"	"<div style=""text-align: center;"">‘c’ y ‘d’</div><hr><ol type=""a""><li>Cierta.</li><li>Cierta.</li><li>Falsa. Es menos costosa. Esta operación en matriz de adyacencia es constante.</li><li>Falsa. Es más costosa en matriz de adyacencia; concretamente es de coste lineal.</li></ol>"
"El problema de la liga de equipos consiste en que dados \(n\) equipos con \(n= 2^k\), se desea realizar una liga de forma que cada equipo puede jugar un partido al día y la liga debe celebrarse en \(n-1\) días, suponiendo que existen suficientes campos de juego. El objetivo sería realizar un calendario que indique el día que deben jugar cada par de equipos. Si este problema se resuelve con un esquema divide y vencerás, considerando que el caso trivial se da cuando la liga consta de 2 equipos, la descomposición se realiza dividiendo el problema en dos partes similares, y la combinación se produce dando los subproblemas por resueltos y aplicando el principio de inducción. Indica de entre los siguientes, cuál sería el coste mínimo de dicho algoritmo.<ol type=""a""><li>\(\Theta(n^{2} \log n)\)</li><li>\(\Theta(n \log n)\)</li><li>\(\Theta(n^{2})\)</li><li>\(\Theta(n)\)</li></ol>"	"<div style=""text-align: center;"">b</div><hr><div style=""text-align: justify;"">Del enunciado se deduce que:</div><ul><li><span style=""text-align: justify;""> </span>\(a = 2\)<span style=""text-align: justify;"">. En cada llamada, el problema se divide en dos subproblemas de tamaño&nbsp;\(n \mathbin{/} 2\)&nbsp;en cada llamada recursiva.</span></li><li style=""text-align: justify;""><div style=""text-align: justify;""> \(b = 2\). Cada subproblema reduce a la mitad el problema original.</div></li></ul><div style=""text-align: justify;"">Dado que se divide a la mitad en cada llamada, la recursión es geométrica. La relación de recurrencia para la misma es</div>\[ T(n) = 2T(n/2) + \Theta(n) \]<br><div style=""text-align: justify;"">Sabemos que el coste de combinar los subproblemas es constante&nbsp;\((k = 1)\)&nbsp;porque se lleva a cabo cuando solo hay dos elementos o cuando volvemos de una llamada recursiva; momento en el que estamos tratando con dos subvectores que ya están ordenados. Esto implica que&nbsp;\(a = b^{k} = 2\)&nbsp;por lo que usamos el caso 2 del Teorema Maestro, que es:&nbsp;</div><div style=""text-align: justify;"">\[\Theta(n^{k} \log{n}) = \Theta (n \log{n})\]<br></div><div style=""text-align: justify;"">Por lo tanto, el coste del algoritmo es \(O(n \log{n})\).</div><div style=""text-align: justify;""><br></div>"
"Indica cuál de las siguientes afirmaciones es cierta:<br><br><ol type=""a""><li>El coste del algoritmo de ordenación rápida en el caso mejor es \(O(n^{2})\), siendo \(n\) el número de elementos del array.</li><li>El coste del algoritmo para fusionar dos subvectores ordenados que se utiliza en la ordenación por fusión es \(O(n)\), siendo \(n\) la suma de los tamaños de los dos vectores.</li><li>El coste del algoritmo que soluciona el problema del coloreado de grafos mediante el esquema de vuelta atrás es \(O(nm)\), siendo \(m\) el número de colores y \(n\) el número de nodos.</li><li>El coste del algoritmo de Kruskal es \(O(n^{2})\), siendo \(n\) el número de nodos del grafo.</li></ol>"	"<div style=""text-align: center;"">b<hr></div><ol type=""a""><li style=""text-align: justify;""><div style=""text-align: justify;"">Habla de quicksort. Es falso porque dice que tiene coste&nbsp;\(O(n^{2})\) <b>en el caso mejor</b>, cuando en realidad es \(O(n \log{n})\). En el caso peor, quicksort si tiene coste \(O(n^{2})\).</div></li><li style=""text-align: justify;""><div style=""text-align: justify;"">Cuando habla de ""la ordenación por fusión"" se refiere a mergesort. ""El coste del algoritmo para fusionar dos subvectores ordenados"" es el coste de la parte de combinación en mergesort, que se hace, efectivamente, en tiempo&nbsp;\(O(n)\). El coste de mergesort como tal es \(O(n \log{n})\).</div></li><li style=""text-align: justify;""><div style=""text-align: justify;"">Es falso. El coste para un algoritmo vuelta atrás sería (según la resolución del texto base)&nbsp;\(O(m^{n})\); siendo \(m\) el número de colores y \(n\) el de nodos. Esto es porque en el peor caso, se tiene que considerar colorear cada nodo con cada uno de los \(m\) colores.</div></li><li style=""text-align: justify;""><div style=""text-align: justify;"">Falso. Es&nbsp;\(O(a \log{n})\) donde \(a\) es el número de aristas/arcos del grafo y \(n\) el de vértices/nodos.</div></li></ol>"
"El algoritmo Quicksort tiene:<br><br><ol type=""a""><li>Caso peor de orden \(O(n^{2} \log n)\)</li><li>Caso medio de orden \(O(n^{2})\)</li><li>Caso mejor de orden \(O(n)\)</li><li>Caso mejor de orden \(O(n \log n)\)</li></ol>"	"<div style=""text-align: center;"">d<hr></div><div style=""text-align: justify;"">Quicksort tiene coste&nbsp;\(O(n \log{n})\) en el mejor caso; que es usando como pivote la mediana del vector, y \(O(n^{2})\) en el caso peor; seleccionando como pivote el primer o último elemento, por ejemplo.</div>"
"¿Cuál de las siguientes afirmaciones es falsa con respecto al coste de las funciones de manipulación de grafos?<ol type=""a""><li>La función \(Adyacentes\), que devuelve una lista con los vértices adyacentes a uno dado, es más costosa cuando el grafo se implementa con una matriz de adyacencia.</li><li>La función \(AñadirVertice\) que añade un vértice a un grafo y devuelve el grafo con dicho vértice incluido, tiene un coste constante cuando el grafo se implementa con una matriz de adyacencia.</li><li>La función \(BorrarArista\) es menos costosa cuando el grafo se implementa mediante una matriz de adyacencia.</li><li>La operación \(Adyacente?\), que comprueba si dos nodos son adyacentes, es más costosa cuando el grafo se implementa con una lista de adyacencia.</li></ol>"	"<div style=""text-align: center;"">b<br><hr></div><ol type=""a""><li style=""text-align: justify;"">Cierta</li><li style=""text-align: justify;"">Falsa. Crear un vértice en una matriz de adyacencia implica hacer una copia completa de la estructura para añadir otra fila y columna correspondientes a ese vértice.</li><li style=""text-align: justify;"">Cierta.</li><li style=""text-align: justify;"">Cierta. En el peor caso se tendrá que recorrer toda la estructura.</li></ol>"
"<div style=""text-align: justify;"">Dado un grafo con&nbsp;\(n\) vértices y \(a\) aristas sobre el que se pueden realizar las siguientes operaciones:</div><ul><li>\(esAdyacente\): comprueba si dos vértices son adyacentes.</li><li>\(borrarVertice\): Borra el vértice especificado y todas sus aristas.</li><li>\(añadirVertice\): Añade un nuevo vértice al grafo.</li></ul><div style=""text-align: justify;"">¿Cuál es la complejidad de cada una de las operaciones anteriores según se utilice una matriz de adyacencia (MA) o una lista de adyacencia (LA)?</div><ol type=""a""><li><table><tbody><tr><th>MA</th><th>LA</th></tr><tr><td>\(esAdyacente\) \(O(1)\)</td><td>\(O(n)\)</td></tr><tr><td>\(borrarVertice\) \(O(n)\)</td><td> \(O(n+a)\)</td></tr><tr><td>\(añadirVertice\) \(O(1)\)</td><td> \(O(1)\)</td></tr></tbody></table></li><li><table><tbody><tr><th>MA</th><th>LA</th></tr><tr><td>\(esAdyacente\) \(O(1)\)</td><td>\(O(1)\)</td></tr><tr><td>\(borrarVertice\) \(O(n)\)</td><td> \(O(n)\)</td></tr><tr><td>\(añadirVertice\) \(O(n)\)</td><td> \(O(1)\)</td></tr></tbody></table></li><li><table><tbody><tr><th>MA</th><th>LA</th></tr><tr><td>\(esAdyacente\) \(O(1)\)</td><td>\(O(n)\)</td></tr><tr><td>\(borrarVertice\) \(O(n)\)</td><td> \(O(n+a)\)</td></tr><tr><td>\(añadirVertice\) \(O(n)\)</td><td> \(O(1)\)</td></tr></tbody></table></li><li><table><tbody><tr><th>MA</th><th>LA</th></tr><tr><td>\(esAdyacente\) \(O(1)\)</td><td>\(O(1)\)</td></tr><tr><td>\(borrarVertice\) \(O(n)\)</td><td> \(O(n)\)</td></tr><tr><td>\(añadirVertice\) \(O(n)\)</td><td> \(O(n)\)</td></tr></tbody></table></li></ol>"	"<div style=""text-align: center;"">c</div><hr><ol type=""a""><li style=""text-align: justify;"">Falso. No hay ningún coste cuadrático en las funciones dadas para la representación de grafos independientemente de la forma de representación.</li><li style=""text-align: justify;""><div style=""text-align: justify;"">Falso.&nbsp;\(esAdyacente\) no es constante en lista de adyacencia.</div></li><li style=""text-align: justify;"">Cierto.</li><li style=""text-align: justify;""><div style=""text-align: justify;"">Falso.&nbsp;\(añadirVertice\) es constante en lista de adyacencia.</div></li></ol>"
"En el problema de colorear un grafo con \( n \) nodos utilizando \( m \) colores, de manera que no haya dos vértices adyacentes que tengan el mismo color, una cota superior ajustada del coste de encontrar una solución utilizando un esquema adecuado es del orden de: <br><br><ol type=""a""><li>\(O(n^{m})\).</li><li>\(O(m^{n})\).</li><li>\(O(n^{2})\).</li><li>\(O(m \log{n})\).</li></ol>"	"<div style=""text-align: center;"">b</div><hr><div style=""text-align: justify;"">Para cada vértice del grafo, se tienen que considerar todas las posibles asignaciones de colores. Si tienes&nbsp;\(n\) nodos y \(m\) colores, entonces hay \(m\) opciones de color para el primer vértice, \(m\) opciones para el segundo vértice\(\dots\) Hasta las \(m\) opciones del nodo \(n\). Esto da lugar a un total de \(m^{n}\) posibles asignaciones de colores a los nodos del grafo.</div>"
"<div style=""text-align: justify;"">Se dispone de un vector&nbsp;\(V\) que almacena números enteros en orden estrictamente creciente y se desea averiguar si existe algún elemento que cumpla \( V[i]=i \). ¿Cuál sería la estrategia más eficiente para resolver el problema?</div><div style=""text-align: justify;""><br></div><ol type=""a""><li>Ninguna de las otras opciones es aplicable al problema</li><li>Divide y vencerás.</li><li>Algoritmo voraz.</li><li>Programación dinámica.</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr>Divide y vencerás. Se puede hacer mediante búsqueda binaria debido a que el vector está ordenado; el coste sería \(O(\log{n})\), que es lo más óptimo comparado con las otras dos estrategias.</div>"
"<div style=""text-align: justify;"">En una carrera de coches por el desierto uno de los principales problemas es el abastecimiento de gasolina. Uno de los participantes está decidido a ganar y ha calculado que con el tanque de gasolina lleno puede recorrer&nbsp;\(M\) km sin parar. El participante dispone de un mapa que le indica las distancias entre las gasolineras que hay en la ruta y cree que, parándose a repostar el menor número de veces posible, podrá ganar. Para ayudarle hay que diseñar un algoritmo que le sugiera en qué gasolineras debe hacerlo. Hay que tener en cuenta que hay una única ruta posible. Indique de los esquemas siguientes cuál es el más adecuado:</div><ol type=""a""><li>El esquema de vuelta atrás.</li><li>El esquema voraz.</li><li>El esquema programación dinámica.</li><li>El esquema de ramificación y poda.</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr>Se podría pensar que la solución consiste en recorrer el menor número de kilómetros hasta llegar a la meta, pero el problema indica de forma explícita que la función a minizar es el número de veces a respostar. Esto se consigue recorriendo en cada arista la mayor distancia posible sin superar los \(M\) km (ya que entonces se quedaría sin gasolina).<br>Debido a que la función puede ser minimizada de forma local en cada vértice, se concluye que la respuesta es el esquema voraz.</div>"
"<div style=""text-align: justify;"">Dado el problema de la mochila donde tenemos una mochila de capacidad&nbsp;\(M\), \(n\) objetos con beneficios \(b_1, b_2, \ldots, b_n\) y pesos \(p_1, p_2, \ldots, p_n\), y siendo el objetivo maximizar el valor de los objetos transportados, respetando la limitación de la capacidad impuesta \(M\), en el caso de que los objetos sean fraccionables, la resolución del mismo:&nbsp;</div><br><ol type=""a""><li>Puede hacerse mediante un esquema voraz pero no es posible resolverlo mediante ramificación y poda.</li><li>Sólo puede resolverse mediante un esquema de programación dinámica.</li><li>Debe hacerse mediante ramificación y poda, ya que no es posible resolverlo utilizando un esquema voraz.</li><li>Debe resolverse mediante un esquema voraz ya que no es eficiente realizarlo mediante ramificación y poda.</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr>No es posible resolverlo mediante un esquema voraz porque puede haber un objeto, después del considerado actualmente, que tenga un mejor beneficio/peso y no pueda ser seleccionado porque el esquema voraz no vuelve a considerar los candidatos seleccionados (o rechazados).<br>La respuesta \(b\) es falsa solo por considerar que puede resolverse con una única estrategia.</div>"
"<div style=""text-align: justify;"">Los residentes de una ciudad no quieren pavimentar todas sus calles (que son de doble sentido), sino sólo aquellas que les permitan ir de una intersección a otra cualquiera de la ciudad con comodidad. Quieren gastarse lo menos posible en la pavimentación, teniendo en cuenta que el coste es directamente proporcional a la longitud de las calles que hay que pavimentar. El alcalde querría saber qué calles tiene que pavimentar para gastarse lo menos posible. ¿Cuál de los siguientes esquemas es más eficiente de los que puedan resolver el problema correctamente?&nbsp;</div><br><ol type=""a""><li>Esquema voraz.</li><li>Esquema de programación dinámica.</li><li>Esquema de vuelta atrás.</li><li>Esquema de ramificación y poda.</li></ol>"	"<div style=""text-align: center;"">a</div><div style=""text-align: justify;""><hr>Se dice que el alcalde quiere gastarse lo menos posible. El coste de una calle es proporcional a su longitud. Si los vértices del grafo del problema son los lugares de la ciudad y las aristas las calles, las etiquetas de las aristas podrían tener de forma indeferente el coste en unidad monetaria o la longitud de la calle, ya que son proporcionales.<br>El enunciado indica que los ciudadanos no quieren pavimentar todas sus calles y quieren poder ir de forma cómoda de una parte de la ciudad a otra. De esto se infiere que lo que se busca es el árbol de recubrimiento mínimo del grafo del problema. La función a minimizar es el coste total de éste árbol, indicado por la suma del valor de las etiquetas de todas sus aristas.<br><br>El problema, por tanto, es equivalente al algoritmo de Prim o Kruskal, que son opciones más eficientes el resto de esquemas propuestos.</div>"
"<div style=""text-align: justify;"">Suponga un algoritmo que dadas dos listas de tamaños&nbsp;\(n\)\(m\)\(A = a_1, \ldots, a_n\)\(B = b_1, \ldots , b_m\)\(A\)\(A\)\(B\) y :  y  dé como resultado la lista de aquellos elementos que pertenecen a  pero no a \*. Se asume que  y  no contienen elementos duplicados, pero no que éstos estén acotados. Indique cuál de los siguientes costes se ajusta más al del algoritmo que puede resolver el problema con menor coste:</div><ol type=""a""><li>\(O(n^{m})\).</li><li>\(Max (O(n \log n), O(m \log m))\).</li><li>\(O(n \log m + m^{2})\).</li><li>\(O(n \log m + m \log m)\).</li></ol>"	"<div style=""text-align: center;"">d</div><div style=""text-align: justify;""><hr>Que no estén acotados quiere decir que en las listas podría haber cualquier elemento del conjunto independientemente de su ""tamaño"". Dado que los elementos de las listas puedan compararse entre ellos, se podrían ordenar ambas listas y luego, para cada elemento de una, llevar a cabo una búsqueda binaria en la otra para determinar si el elemento se encuentra en la misma.<br>Para la ordenación de las listas se podría usar \(Heapsort\), por lo que ordenar \(A\) tendría un coste de \(O(n \log{n})\) mientras que en \(B\) sería de \(O(m \log{m})\). El coste total hasta el momento sería \(O(n \log{n})+O(m \log{m})\)<br> Si la búsqueda binaria se hace cogiendo los elementos de \(A\) y buscándolos en \(B\), el coste sería de \(O(n \log{m})\). Del coste total anterior podemos despreciar el coste de \(O(n \log{n})\) para sustituirlo por \(O(n \log{m})\) y por ello el coste total final es de \(O(n \log m + m \log m)\).</div>"
"<div style=""text-align: justify;""><div style=""text-align: justify;"">Dado un grafo con&nbsp;\( n \) vértices y \( a \) aristas sobre el que se pueden realizar las siguientes operaciones:&nbsp;</div></div><ul><li>\(esAdyacente\): comprueba si dos vértices son adyacentes.</li><li>\(borrarVertice\): Borra el vértice especificado y todas sus aristas.</li><li>\(anadirVertice\): Añade un nuevo vértice al grafo.</li></ul><div style=""text-align: justify;"">¿Cuál es la complejidad de cada una de las operaciones anteriores según se utilice una matriz de adyacencia (MA) o una lista de adyacencia (LA)?&nbsp;</div><br><ol type=""a""><li>MA: <table><tbody><tr><th>\(esAdyacente\) \(O(1)\)\(O(1)\)</th><th>\(borrarVertice\) \(O(n)\)\(O(n)\)</th><th>\(anadirVertice\) \(O(n)\)\(O(n)\)</th></tr></tbody></table> LA: <table><tbody><tr><th>\(esAdyacente\) \(O(1)\)\(O(1)\)</th><th>\(borrarVertice\) \(O(n)\)\(O(n+a)\)</th><th>\(anadirVertice\) \(O(n)\)\(O(1)\)</th></tr></tbody></table></li><li>MA: <table><tbody><tr><th>\(esAdyacente\) \(O(1)\)\(O(1)\)</th><th>\(borrarVertice\) \(O(n)\)\(O(n)\)</th><th>\(anadirVertice\) \(O(n)\)\(O(1)\)</th></tr></tbody></table> LA: <table><tbody><tr><th>\(esAdyacente\) \(O(1)\)\(O(n)\)</th><th>\(borrarVertice\) \(O(n)\)\(O(n+a)\)</th><th>\(anadirVertice\) \(O(n)\)\(O(1)\)</th></tr></tbody></table></li><li>MA: <table><tbody><tr><th>\(esAdyacente\) \(O(1)\)\(O(1)\)</th><th>\(borrarVertice\) \(O(1)\)\(O(n+a)\)</th><th>\(anadirVertice\) \(O(1)\)\(O(1)\)</th></tr></tbody></table> LA: <table><tbody><tr><th>\(esAdyacente\) \(O(1)\)\(O(n)\)</th><th>\(borrarVertice\) \(O(n)\)\(O(n+a)\)</th><th>\(anadirVertice\) \(O(n)\)\(O(1)\)</th></tr></tbody></table></li><li>MA: <table><tbody><tr><th>\(esAdyacente\) \(O(1)\)\(O(1)\)</th><th>\(borrarVertice\) \(O(n)\)\(O(n)\)</th><th>\(anadirVertice\) \(O(n)\)\(O(1)\)</th></tr></tbody></table> LA: <table><tbody><tr><th>\(esAdyacente\) \(O(1)\)\(O(n)\)</th><th>\(borrarVertice\) \(O(n)\)\(O(n)\)</th><th>\(anadirVertice\) \(O(n)\)\(O(n)\)</th></tr></tbody></table></li></ol>"	"<div style=""text-align: center;"">?</div><div style=""text-align: justify;""><hr>No parece que haya una respuesta correcta: <ol type=""a""><li>Falso. \(esAdyacente\) no es constante en lista de adycencia.</li><li>Falso. \(anadirVertice\)&nbsp;no es constante en matriz de adyacencia.</li><li>Falso. \(anadirVertice\)&nbsp;no es constante en matriz de adyacencia.</li><li>Falso. \(anadirVertice\)&nbsp;no es constante en matriz de adyacencia.</li></ol></div>"
"<div style=""text-align: justify;"">Indique cuál de las siguientes afirmaciones es cierta:&nbsp;</div><ol type=""a""><li style=""text-align: justify;"">El esquema de programación voraz se aplica a problemas de optimización en los que la solución se puede construir paso a paso comprobando, en cada paso, la secuencia de decisiones tomadas anteriormente.</li><li style=""text-align: justify;"">La programación dinámica tiene como principal ventaja que supone un decremento tanto en coste computacional como en espacio de almacenamiento.</li><li style=""text-align: justify;"">La programación dinámica se puede emplear en muchos de los problemas que se resuelven utilizando el esquema divide y vencerás.</li><li style=""text-align: justify;"">El esquema de ramificación y poda es el más indicado a utilizar en el caso que se deseen encontrar todas las soluciones posibles a un problema dado.</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr>Nada que comentar.</div>"
"<div style=""text-align: justify;"">En el recorrido mediante doble hashing, la función&nbsp;\(h'(x)\) debe cumplir:</div><ol type=""a""><li>Se debe cumplir que \(h'(x) &lt; h(x) + c\), con \( c \) constante.</li><li>\(h'(x)\) debe tener la forma \(h'(x) = 2h(x) + c\), con \(c\) constante.</li><li>Necesariamente debe ser \(h'(x) \neq 0\).</li><li>Ninguna de las otras opciones es cierta.</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr>Es rebuscada. Mirando la teoría se ve que es la \(c\): si \(h'(x) = 0\) se producen colisiones.</div>"
"<div style=""text-align: justify;"">Con respecto a la resolución de colisiones en las funciones Hash se puede afirmar que:</div><ol type=""a""><li style=""text-align: justify; "">El hashing abierto contempla un método de resolución conocido como “recorrido mediante doble hashing”.</li><li style=""text-align: justify;"">Si el factor de carga es 1 se puede resolver mediante hashing cerrado.</li><li style=""text-align: justify;"">El recorrido lineal permite mayor dispersión de las colisiones que el cuadrático.</li><li style=""text-align: justify; "">Ninguna de las otras opciones es correcta.</li></ol>"	"<div style=""text-align: center;"">d</div><div style=""text-align: justify;""><hr>El hashing abierto consiste en usar extructuras externas a la tabla para resolver colisiones; el hashing cerrado en buscar una celda alternativa en la tabla.<br> <ol type=""a""><li>El recorrido mediante doble hashing es una estrategia de hashing cerrado.</li><li>El factor de carga es un valor entre 0 y 1 que se calcula como la división de las celdas ocupadas entre el total de las celdas de la tabla. Si es 1, significa que la tabla está totalmente ocupada por lo que no podrá aplicarse hashing cerrado.</li><li>Es al revés.</li><li>Ninguna de las anteriores es cierta por lo que la respuesta correcta es esta.</li></div>"
"<div style=""text-align: justify;"">Durante la ejecución de un algoritmo de Ramificación y Poda se halla una solución que es mejor que la mejor solución existente en ese momento y que mejora la estimación optimista de la cima del montículo. Esto implica:</div><ol type=""a""><li>Definitivamente el algoritmo ha encontrado la solución.</li><li>Se actualiza la cota y se sigue con la exploración porque no hemos terminado.</li><li>Se actualiza la cima del montículo y se sigue con la exploración porque no hemos terminado.</li><li>Ninguna de las otras opciones es correcta.</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr><ol type=""a""><li>No tiene porqué serlo.</li><li>Cierta.</li><li>Falsa porque se podría estar usando otra estructura en vez de un montículo (debatible). </li><li>Falsa.</li></div>"
"<div style=""text-align: justify;"">Se dispone de&nbsp;\(n\) cubos numerados del 1 a \(n\). Cada cubo tiene impresa una letra distinta en cada una de sus caras, aunque distintos cubos pueden tener letras repetidas. Se pretende, dada una palabra de longitud \(n\), colocar el total de cubos de manera consecutiva de forma que se forme la palabra dada. ¿Cuál de los siguientes esquemas algorítmicos es el más apropiado para resolver dicho problema?</div><ol type=""a""><li>Vuelta atrás.</li><li>Ramificación y poda.</li><li>Divide y vencerás.</li><li>Programación dinámica.</li></ol>"	"<div style=""text-align: center;"">a</div><div style=""text-align: justify;""><hr>Se requiere explorar de manera exhaustiva todas las posibles combinaciones. No parece que se puedan establecer cotas que permitan podar el árbol de búsqueda por lo que el esquema más apropiado es vuelta atrás.</div>"
"<div style=""text-align: justify;"">Considere un array&nbsp;\( A[1..n] \) ordenado y formado por enteros diferentes, algunos de los cuales pueden ser negativos. Se busca un algoritmo recursivo que calcule en tiempo logarítmico un índice \( i \) tal que \( 1 \leq i \leq n \) y \( A[i] = i \), siempre que este índice exista. Se supone que las operaciones elementales tienen coste unitario. ¿A cuál de los siguientes esquemas correspondería dicho algoritmo?</div><ol type=""a""><li>Esquema de vuelta atrás.</li><li>Divide y vencerás.</li><li>Esquema voraz.</li><li>Esquema de ramificación y poda.</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr>Se puede hacer mediante búsqueda binaria.</div>"
"<div style=""text-align: justify;"">Indica cuál de las siguientes afirmaciones es correcta:</div><ol type=""a""><li style=""text-align: justify;"">El mejor método para resolver los problemas de planificación con plazo fijo es mediante el esquema de Vuelta Atrás.</li><li style=""text-align: justify;"">En el problema de la mochila con solución voraz, necesariamente los objetos pueden fraccionarse, de lo contrario no es posible resolverlo mediante un esquema voraz.</li><li style=""text-align: justify;"">El coste de un algoritmo de ordenación por fusión es lineal si el vector está ya previamente ordenado.</li><li style=""text-align: justify;"">Ninguna de las otras opciones es correcta.</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr><ol type=""a""><li>No tiene porqué serlo.</li><li>Cierta.</li><li>Falsa. El coste de Mergesort en el peor, mejor y caso medio es \(O(n \log{n})\).</li><li>Falsa.</li></div>"
"<div style=""text-align: justify;"">Los algoritmos de Prim y Kruskal son algoritmos voraces que se aplican a la hora de calcular un árbol de recubrimiento mínimo. En relación a ambos algoritmos, cuál de las siguientes afirmaciones es cierta.</div><ol type=""a""><li style=""text-align: justify;"">Prim es más eficiente en el caso de un grafo muy disperso, mientras Kruskal es más eficiente si el grafo es muy denso.</li><li style=""text-align: justify;"">Prim parte de un nodo arbitrario, mientras Kruskal parte del conjunto de aristas ordenadas de menor a mayor coste.</li><li style=""text-align: justify;"">Al inicializar el algoritmo Prim selecciona un nodo arbitrario mientras Kruskal elige aquel nodo con menor número de aristas.</li><li style=""text-align: justify;"">Ninguna de las otras opciones.</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr><ol type=""a""><li>Falsa. Kruskal siempre tiene coste \(O(a \log{n})\), al igual que Prim cuando el grafo es disperso. \(a\) es el número de aristas y \(n\) el de nodos. </li><li>Debatible. No se especifica a que se refiere con el hecho de que el algoritmo parta desde un punto. Al comenzar la ejecución del algoritmo, Kruskal tiene que ordenar las aristas de forma creciente; no empieza con ellas ya ordenadas. </li><li>Falsa. Kruskal elige la siguiente arista de la estructura en las que las haya ordenado.</li><li>Debatible.</li></div>"
"<div style=""text-align: justify;"">Dos piratas se pretenden repartir a partes iguales el tesoro acumulado en sus años de saqueos. Cada objeto robado tiene un valor. Como ambos piratas tienen sus preferencias por algunos objetos, antes de decidir los que se quedan quieren saber todas las posibles formas de repartir el tesoro en dos partes iguales. Indica qué esquema de los siguientes sería el más adecuado para diseñar un algoritmo que hiciera esa tarea.&nbsp;</div><ol type=""a""><li style=""text-align: justify;"">Divide y vencerás.</li><li style=""text-align: justify;"">Algoritmo voraz.</li><li style=""text-align: justify;"">Vuelta atrás.</li><li style=""text-align: justify;"">Ramificación y poda.</li></ol>"	"<div style=""text-align: center;"">d</div><div style=""text-align: justify;""><hr>Vuelta atrás; se quiere explorar todo el espacio de soluciones.</div>"
"<div style=""text-align: justify;"">Indica cuál de las siguientes afirmaciones es cierta con respecto al problema de la devolución de cambio de moneda utilizando un número mínimo de monedas y suponiendo que la disponibilidad de cada tipo de moneda es ilimitada:</div><ol type=""a""><li style=""text-align: justify;"">El problema de la devolución de cambio de moneda se puede resolver para todo sistema monetario utilizando una estrategia voraz, siempre que en el sistema se disponga de un tipo de moneda de 1.</li><li style=""text-align: justify;""><div style=""text-align: justify;"">Si se dispone de&nbsp;\( n \) tipos de moneda \( T = \{ m_0, m_1, m_2, \ldots, m_n \} \) siendo \( m &gt; 1 \) y \( n &gt; 0 \), el problema de la devolución de cambio de moneda no se puede resolver utilizando una estrategia voraz.</div></li><li style=""text-align: justify;"">El problema de la devolución de cambio de moneda para cualquier sistema monetario, siempre que en el sistema se disponga de un tipo de moneda de 1, se puede resolver utilizando los esquemas de programación dinámica y de ramificación y poda.</li><li style=""text-align: justify;"">El problema de la devolución de cambio de moneda para cualquier sistema monetario, siempre que en el sistema se disponga de un tipo de moneda de 1, se puede resolver utilizando el esquema de programación dinámica pero no el de ramificación y poda.</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><ol type=""a""><li>Falsa. En un sistema con monedas de 1, 3 y 4 unidades, la estrategia voraz para cambiar 6 unidades elegiría dos monedas de 3, en lugar de una moneda de 4 y dos de 1, que sería la solución óptima.</li><li>Falsa. En un sistema con monedas 2, 3 y 4, la estrategia voraz para cambiar 2 monedas devolvería la solución óptima.</li><li>Cierta, aunque no se necesita necesariamente que haya un tipo de moneda 1. </li><li>Falsa. También se podrá resolver con ramificación y poda.</li></div>"
"<div style=""text-align: justify;"">Indica cuál de las siguientes afirmaciones es cierta con respecto a la resolución de colisiones:</div><ol type=""a""><li style=""text-align: justify;""><div style=""text-align: justify;"">En el método de hashing cerrado con recorrido mediante doble hashing la función&nbsp;\( h \) y \( h' \) que se aplican pueden ser iguales cuando el número de elementos de la tabla, \( m \), cumple determinadas condiciones.</div></li><li style=""text-align: justify;"">El método de hashing abierto es siempre más eficiente que el hashing cerrado para la resolución de colisiones.</li><li style=""text-align: justify;"">En el método de hashing cerrado con recorrido lineal existe una probabilidad muy baja de colisiones independientemente de los patrones de las claves.</li><li style=""text-align: justify;""><div style=""text-align: justify;"">En el método de hashing cerrado con recorrido cuadrático es posible garantizar que se van a recorrer todos los elementos de la tabla cuando el número de elementos de la tabla,&nbsp;\( m \), cumple determinadas condiciones.</div></li></ol>"	"<div style=""text-align: center;"">d</div><div style=""text-align: justify;""><hr><ol type=""a""><li style=""text-align: justify; "">Falsa. No pueden ser iguales.</li><li style=""text-align: justify;"">Falsa. No tiene porqué ser así.</li><li style=""text-align: justify;"">Falsa. No tiene porqué ser así. </li><li style=""text-align: justify; ""><div style=""text-align: justify;"">Cierta. ""si el tamaño de la tabla&nbsp;\(m\) es un número primo y se usa una función de desplazamiento que asegura que todos los desplazamientos posibles se consideren, se puede garantizar que todos los elementos de la tabla serán recorridos. Esto se debe a que el método cuadrático evita el problema de clústeres primarios y al usar un número primo para el tamaño de la tabla, se asegura una exploración completa de las posiciones posibles"".</div></li></ol></div>"
"<div style=""text-align: justify;"">Se dispone de cuatro tipos de monedas de valores 1, 2, 4 y 8. Se desea resolver el problema de pagar una cantidad&nbsp;\( C &gt; 0 \) utilizando un número mínimo de monedas y suponiendo que la disponibilidad de cada tipo de moneda es ilimitada. ¿Cuál de los siguientes esquemas es más eficiente de los que puedan resolver el problema correctamente?&nbsp;</div><br> <ol type=""a""><li>Esquema de vuelta atrás.</li><li>Esquema de programación dinámica.</li><li>Esquema voraz.</li><li>Esquema de ramificación y poda.</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr>Nada que comentar.</div>"
"<div style=""text-align: justify; "">Considere dos vectores&nbsp;\( f \)&nbsp;y&nbsp;\( g \)&nbsp;de&nbsp;\( n \)&nbsp;elementos que representan los valores que toman dos funciones en el intervalo&nbsp;\([0..n-1]\). Los dos vectores están ordenados, pero el primero&nbsp;\( f \)&nbsp;es un vector estrictamente creciente (\( f[0] &lt; f[1] &lt; \dots &lt; f[n-1] \)), mientras&nbsp;\( g \)&nbsp;es un vector estrictamente decreciente (\( g[0] &gt; g[1] &gt; \dots &gt; g[n-1] \)). Las curvas que representan dichos vectores se cruzan en un punto concreto, y lo que se desea saber es si dicho punto está contenido entre las componentes de ambos vectores, es decir, si existe un valor&nbsp;\( i \)&nbsp;tal que&nbsp;\( f[i] = g[i] \)&nbsp;para&nbsp;\( 0 \leq i \leq n - 1 \). La figura muestra un ejemplo en el que las gráficas se cruzan en&nbsp;\( i=8 \)&nbsp;que se corresponde con el valor 25 en ambas curvas. Se busca un algoritmo que compruebe si el punto de cruce está contenido en las componentes de ambos vectores.&nbsp;</div><img src=""uned-preda_19.png""><br>¿Cuál de las siguientes opciones es cierta?<ol type=""a""><li>Ninguna de las otras opciones.</li><li>El algoritmo más eficiente que se puede encontrar es&nbsp;\( O(n) \).</li><li>Se puede encontrar un algoritmo recursivo de coste logarítmico.</li><li>El algoritmo más eficiente que se puede encontrar es&nbsp;\( O(n^2) \).</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Se puede realizar una búsqueda binaria sobre ambos vectores al mismo tiempo porque están ordenados. No importa que uno esté ordenado de forma decreciente y el otro de forma creciente ya que la búsqueda puede ser respecto a uno de los vectores y luego comprobar, en el mismo índice del otro vector, si el elemento es el mismo.</div></div>"
"<div style=""text-align: justify;"">¿Cuál de las siguientes afirmaciones es falsa?</div><ol type=""a""><li style=""text-align: justify;""><div style=""text-align: justify;"">El algoritmo de ordenación rápida en el caso peor es&nbsp;\( O(n^2) \).</div></li><li style=""text-align: justify;""><div style=""text-align: justify;"">El algoritmo de ordenación por fusión (mergesort) es&nbsp;\( O(n \log n) \).</div></li><li style=""text-align: justify;"">La eficiencia del algoritmo de ordenación rápida (quicksort) es independiente de que el pivote sea el elemento de menor valor del vector.</li><li style=""text-align: justify;""><div style=""text-align: justify;"">El algoritmo de ordenación basada en montículos (heapsort) es&nbsp;\( O(n \log n) \).</div></li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr>Nada que comentar.</div>"
"<div style=""text-align: justify;"">¿Cuál de las siguientes afirmaciones es falsa?</div><ol type=""a""><li style=""text-align: justify;"">Un grafo nulo es un grafo sin vértices.</li><li style=""text-align: justify;"">Un camino en un grafo dirigido es una secuencia finita de arcos entre dos vértices, tal que el vértice del extremo final de cada arco coincide con el del extremo inicial del arco siguiente.</li><li style=""text-align: justify;"">El grado de un vértice de un grafo no dirigido es el número de aristas que salen o entran en él.</li><li style=""text-align: justify;"">La longitud de un camino es el número de aristas y nodos que contiene.</li></ol>"	"<div style=""text-align: center;"">d</div><div style=""text-align: justify;""><hr>Nada que comentar.</div>"
"<div style=""text-align: justify;"">Indique cuál de las siguientes afirmaciones es cierta:&nbsp;</div><div style=""text-align: justify;""><br></div> <ol type=""a""><li style=""text-align: justify;"">Ninguna de las otras opciones es cierta.</li><li style=""text-align: justify;""><div style=""text-align: justify;"">La ordenación por Quicksort tiene coste&nbsp;\( O(n^2) \) en el caso peor.</div></li><li style=""text-align: justify;"">La búsqueda en profundidad recursiva obtiene siempre una eficiencia logarítmica.</li><li style=""text-align: justify;""><div style=""text-align: justify;"">El esquema de divide y vencerás obtiene siempre soluciones eficientes de coste&nbsp;\( O(\log n) \) o \( O(n \log n) \).</div></li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr>Nada que comentar.</div>"
"<div style=""text-align: justify;"">El enemigo ha desembarcado en nuestras costas invadiendo&nbsp;\( n \) ciudades. Los servicios de inteligencia han detectado del número de efectivos enemigos en cada ciudad, \( e_i \). Para contraatacar, se dispone de \( n \) equipos listos para intervenir y hay que distribuirlos entre las \( n \) ciudades. Cada uno de estos equipos consta de \( d_j \) efectivos entrenados y equipados. Para garantizar el éxito de la intervención en una ciudad es necesario que contemos al menos con tantos efectivos de defensa como el enemigo. Se busca un algoritmo que indique qué equipo debe intervenir en cada ciudad, de forma que se maximice el número de éxitos garantizados. Indica cuál de las siguientes afirmaciones es cierta:</div><ol type=""a""><li>El esquema de vuelta atrás es el más apropiado para resolver este problema.</li><li>Se puede encontrar una estrategia voraz que permita resolver el problema.</li><li>El esquema de ramificación y poda es el único que puede resolver de forma óptima el problema.</li><li>El esquema de programación dinámica es el único que puede resolver de forma óptima el problema.</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr>Nada que comentar.</div>"
"<div style=""text-align: justify;"">Indica de entre los siguientes, cuál sería el coste mínimo de un algoritmo que dado un vector&nbsp;\( C[1..n] \) de números enteros distintos no ordenado, y un entero \( S \), determine si existen o no dos elementos de \( C \) tales que su suma sea exactamente \( S \).</div><ol type=""a""><li>\( \Theta(n \log n) \)</li><li>\( \Theta(n^2) \)</li><li>\( \Theta(n) \)</li><li>\( \Theta(n^2 \log n) \)</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Se puede usar un hash set para comprobar, para cada elemento&nbsp;\(C[i]\), si \(S - C[i]\) existe en el conjunto. El coste sería \(O(n)\). Dado que en la asignatura no se ven algoritmos que usen un hash set, en el exámen seguramente se podría marcar la \(a\) argumentando que el vector puede ordenarse y luego ejecutar una búsqueda binaria sobre cada elemento para ver si \(S - C[i]\) existe en el mismo.</div></div>"
"<div style=""text-align: justify;"">Indique cuál de las siguientes afirmaciones es cierta:</div><ol type=""a""><li style=""text-align: justify;"">Cuando ambos son aplicables, el enfoque de ramificación y poda se comporta de manera más eficiente que el enfoque voraz en la resolución de problemas de optimización.</li><li style=""text-align: justify;"">El enfoque de vuelta atrás realiza un recorrido en anchura del árbol implícito que representa el espacio de posibles soluciones del problema.</li><li style=""text-align: justify;""><div style=""text-align: justify;"">Si se utiliza el enfoque de programación dinámica para calcular el camino de coste mínimo entre cada par de nodos de un grafo, la complejidad temporal es de&nbsp;\( O(n^2) \).</div></li><li style=""text-align: justify;"">El hecho de utilizar un algoritmo voraz para obtener la solución de un problema no garantiza que la solución obtenida sea la óptima.</li></ol>"	"<div style=""text-align: center;"">d</div><div style=""text-align: justify;""><hr><ol type=""a""><li style=""text-align: justify;"">Falsa. Es al revés.</li><li style=""text-align: justify;"">Falsa. El recorrido es en profundidad.</li><li style=""text-align: justify;""><div style=""text-align: justify;"">Falsa. El algoritmo de programación dinámica más comúnmente utilizado para encontrar el camino de coste mínimo entre todos los pares de nodos en un grafo es el algoritmo de Floyd-Warshall, que tiene una complejidad temporal de&nbsp;\(O(n^{3})\) es el número de nodos del grafo.</div></li><li style=""text-align: justify;"">Cierta.</li></ol></div>"
"<div style=""text-align: justify;"">Una filmoteca ha organizado un maratón de cortometrajes. Durante 24 horas se proyectarán cortos de cine (todos diferentes) en las&nbsp;\( n \) salas disponibles. Un cinéfilo ha conseguido la programación completa donde aparecen todas las películas que se van a proyectar durante el maratón, incluyendo el título, duración del corto, sala en la que se proyecta y hora de comienzo. Si se quiere planificar el maratón del cinéfilo de forma que pueda ver el máximo número posible de cortos, ¿Cuál es el esquema más apropiado para hacer la planificación eficientemente?</div><ol type=""a""><li>Esquema de ramificación y poda.</li><li>Esquema de vuelta atrás.</li><li>Esquema voraz.</li><li>Divide y vencerás.</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">El problema es similar al de la selección de actividades o problema del intervalo máximo. Los cortos se pueden ordenar en un vector por hora de comienzo y luego recorrerlo seleccionándo el corto siempre que su hora de comienzo no se solape con la del corto anterior. El esquema, por tanto, es voraz.</div></div>"
"<div style=""text-align: justify;"">Sea el problema de la mochila, en el que tenemos una mochila de capacidad&nbsp;\( M \), \( n \) objetos con beneficios \( b_1, b_2, b_3, \ldots, b_n \) y pesos \( p_1, p_2, p_3, \ldots, p_n \). El objetivo es maximizar el valor de los objetos transportados, respetando la limitación de la capacidad impuesta \( M \). Indica de los esquemas siguientes cuál es el más adecuado en el caso de que cada objeto puede meterse en la mochila, no meterse, o meter la mitad del objeto obteniendo la mitad del beneficio.</div><ol type=""a""><li>El esquema de ramificación y poda.</li><li>El esquema de vuelta atrás.</li><li>El esquema voraz.</li><li>El esquema divide y vencerás.</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr>Dado que los objetos pueden fraccionarse, el esquema más apropiado es el voraz.</div>"
"<div style=""text-align: justify;"">En relación a la representación de grafos mediante listas de adyacencia, indique cuál de las siguientes afirmaciones es falsa:</div><ol type=""a""><li style=""text-align: justify;""><div style=""text-align: justify;"">El coste asociado a la operación Añadir Vértice es&nbsp;\( O(1) \).</div></li><li style=""text-align: justify;""><div style=""text-align: justify;"">Sea&nbsp;\( n \) el número de nodos del grafo, necesitaremos \( n \) listas para representarlo.</div></li><li style=""text-align: justify;"">Si el grafo presenta pocas aristas, es más eficiente en espacio representarlo mediante listas de adyacencia que representarlo mediante una matriz de adyacencia.</li><li style=""text-align: justify;""><div style=""text-align: justify;"">El coste asociado a la operación Borrar Arista es&nbsp;\( O(n + a) \), siendo \( n \) el número de nodos del grafo y siendo \( a \) el número de aristas.</div></li></ol>"	"<div style=""text-align: center;"">d</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">El coste de borrar una arista en lista de adyacencia es&nbsp;\(O(n)\) respecto el número de aristas. La operación que tiene coste \(O(n+a)\) respecto el número de nodos y aristas, respectivamente, es borrar vértice.</div></div>"
"<div style=""text-align: justify;"">Indica cuál de las siguientes afirmaciones es cierta:</div><ol type=""a""><li style=""text-align: justify;"">Ninguna de las otras definiciones es completa y cierta.</li><li style=""text-align: justify;"">Un ciclo es un camino simple que empieza y termina en el mismo vértice.</li><li style=""text-align: justify;"">Un árbol libre es un grafo acíclico, conexo y dirigido.</li><li style=""text-align: justify;"">Si un grafo tiene pocas aristas las listas de adyacencia resultan una estructura más costosa en espacio que la matriz de adyacencia.</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr><ol type=""a""><li style=""text-align: justify;""><div style=""text-align: justify;"">Falso. La&nbsp;\(b\) es cierta.</div></li><li style=""text-align: justify;"">Cierta.</li><li style=""text-align: justify;"">Un árbol libre (o simplemente un árbol) es un grafo conexo y acíclico, pero no necesariamente dirigido.</li><li style=""text-align: justify;"">Falso. Es al revés.</li></ol></div>"
"<div style=""text-align: justify;"">Indica cuál de las siguientes afirmaciones es cierta con respecto al problema de la devolución de cambio de moneda utilizando un número mínimo de monedas y suponiendo que la disponibilidad de cada tipo de moneda es ilimitada:</div><ol type=""a""><li style=""text-align: justify;"">El problema de la devolución de cambio de moneda se puede resolver para todo sistema monetario utilizando una estrategia voraz, siempre que en el sistema se disponga de un tipo de moneda de 1.</li><li style=""text-align: justify;""><div style=""text-align: justify;"">Si se dispone de&nbsp;\( n \) tipos de moneda \( T = \{m_0, m_1, m_2, \ldots, m_n\} \) siendo \( m &gt; 1 \) y \( n &gt; 0 \), el problema de la devolución de cambio de moneda no se puede resolver utilizando una estrategia voraz.</div></li><li style=""text-align: justify;"">El problema de la devolución de cambio de moneda para cualquier sistema monetario, siempre que en el sistema se disponga de un tipo de moneda de 1, se puede resolver utilizando los esquemas de programación dinámica y de ramificación y poda.</li><li style=""text-align: justify;"">El problema de la devolución de cambio de moneda para cualquier sistema monetario, siempre que en el sistema se disponga de un tipo de moneda de 1, se puede resolver utilizando el esquema de programación dinámica pero no el de ramificación y poda.</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><ol type=""a""><li style=""text-align: justify;"">Falso. No siempre es cierto.</li><li style=""text-align: justify;""><div style=""text-align: justify;"">Falso. Para un sistema de 3 monedas donde&nbsp;\(T=\{2,3,4\}\) y una cantidad a cambiar de 2, el esquema voraz encuentra una solución óptima.</div></li><li style=""text-align: justify;"">Cierta.</li><li style=""text-align: justify;"">Falso.</li></ol></div>"
"<div style=""text-align: justify;"">Se dispone de cuatro tipos de monedas de valores 1, 2, 4 y 8. Se desea resolver el problema de pagar una cantidad&nbsp;\( C &gt; 0 \) utilizando un número mínimo de monedas y suponiendo que la disponibilidad de cada tipo de moneda es ilimitada. ¿Cuál de los siguientes esquemas es más eficiente de los que puedan resolver el problema correctamente?</div><ol type=""a""><li>Esquema de vuelta atrás.</li><li>Esquema de programación dinámica.</li><li>Esquema voraz.</li><li>Esquema de ramificación y poda.</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Dado que cada moneda del conjunto disponible es un múltiplo de las anteriores, el esquema más eficiente es el voraz para cualquier entero&nbsp;\(C &gt; 0\).</div></div>"
"<div style=""text-align: justify;"">Se dispone de un conjunto&nbsp;\( A \) de \( n \) números enteros (tanto positivos como negativos) sin repeticiones almacenados en una lista. Dados dos valores enteros \( m \) y \( C \), siendo \( m &lt; n \) se desea resolver el problema de encontrar un subconjunto de \( A \) compuesto por exactamente \( m \) elementos y tal que la suma de los valores de esos \( m \) elementos sea \( C \). ¿Cuál de los siguientes esquemas es más eficiente de los que puedan resolver el problema correctamente?</div><ol type=""a""><li>Esquema voraz.</li><li>Esquema de divide y vencerás.</li><li>Esquema de vuelta atrás.</li><li>Esquema de ramificación y poda.</li></ol>"	"<div style=""text-align: center;"">d</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Un esquema voraz no siempre garantiza una solución óptima para este caso. Tampoco parece que haya una forma clara de subdividir el problema en subproblemas más pequeños. El esquema de vuelta atrás garantiza una solución a un coste ineficiente\(\binom{n}{m}\) comparado con un esquema de ramificación y poda, que puede podar aquellas ramas no prometedoras del árbol de soluciones.&nbsp;</div></div>"
"<div style=""text-align: justify;"">Dado el problema de la devolución del cambio para una cantidad&nbsp;\( C &gt; 0 \). Indica cuál de estas afirmaciones es cierta.</div><ol type=""a""><li>El esquema de vuelta atrás es el más apropiado para resolver este problema cuando se dispone de un conjunto finito de tipos de moneda \( T = \{m_0, m_1, m_2, \ldots, m_n\} \), siendo \( m &gt; 1 \) y \( n &gt; 0 \).</li><li>El esquema de ramificación y poda es el único que puede resolver de forma óptima el problema cuando se dispone de un conjunto finito de tipos de moneda \( T = \{m_0, m_1, m_2, \ldots, m_n\} \), siendo \( m &gt; 1 \) y \( n &gt; 0 \).</li><li>Se puede encontrar una estrategia voraz que permita resolver el problema de forma óptima para cualquier conjunto de monedas.</li><li>El esquema de programación dinámica puede resolver de forma óptima el problema cuando no se cumpla que \( T = \{m_0, m_1, m_2, \ldots, m_n\} \), siendo \( m &gt; 1 \) y \( n &gt; 0 \).</li></ol>"	"<div style=""text-align: center;"">d</div><div style=""text-align: justify;""><hr><ol type=""a""><li>Falso. No tiene porqué.</li><li>Falso. No tiene porqué.</li><li>Falso. No es verdad siempre.</li><li>Cierta.</li></ol></div>"
"<div style=""text-align: justify;"">En relación al esquema algorítmico de vuelta atrás, ¿cuál de las siguientes afirmaciones es cierta?:</div><ol type=""a""><li style=""text-align: justify;"">Siempre es más eficiente que el esquema voraz, de forma que, si ambos son aplicables, nos decantaremos por utilizar el esquema de vuelta atrás.</li><li style=""text-align: justify;"">Aun existiendo una solución al problema, puede darse el caso de que el esquema de vuelta atrás no la encuentre.</li><li style=""text-align: justify;"">Implementa un recorrido en amplitud de forma recursiva sobre el grafo implícito del problema.</li><li style=""text-align: justify;"">Todas las afirmaciones son falsas.</li></ol>"	"<div style=""text-align: center;"">d</div><div style=""text-align: justify;""><hr><ol type=""a""><li>Falso.</li><li>Falso. Recorre todo el árbol de posibles soluciones.</li><li>Falso. El recorrido es en profundidad.</li><li>Cierta.</li></ol></div>"
"<div style=""text-align: justify;"">Indica cuál de las siguientes afirmaciones relativas a las tablas de dispersión es falsa:</div><ol type=""a""><li style=""text-align: justify;"">Una función hash debe ser eficiente e indeterminista.</li><li style=""text-align: justify;""><div style=""text-align: justify;"">Una función hash debe repartir los valores&nbsp;\(h(x)\) en la tabla de manera equiprobable.</div></li><li style=""text-align: justify;"">En la resolución de colisiones, el recorrido basado en una expresión cuadrática en lugar de lineal permite una mayor dispersión de las colisiones.</li><li style=""text-align: justify;""><div style=""text-align: justify;"">Cambios pequeños en la clave deben resultar en cambios significativos en la función hash&nbsp;\(h(x)\).</div></li></ol>"	"<div style=""text-align: center;"">a</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Una función hash debe ser determinista: producir siempre el mismo resultado para la misma entrada.</div></div>"
"<div style=""text-align: justify;"">Para resolver determinado problema hemos diseñado un algoritmo voraz. Indique cuál de las siguientes afirmaciones es falsa:</div><ol type=""a""><li style=""text-align: justify;"">Si encontramos un contraejemplo en el que el algoritmo no alcanza la solución óptima debemos probar con el siguiente valor distinto que nos proporcione la función de selección.</li><li style=""text-align: justify;"">Si encontramos un contraejemplo en el que el algoritmo no alcanza la solución óptima podemos afirmar que no es correcto.</li><li style=""text-align: justify;"">Necesitamos una demostración de optimalidad para poder asegurar que el algoritmo alcanza la solución óptima.</li><li style=""text-align: justify;"">La función de selección escoge al mejor de los candidatos restantes.</li></ol>"	"<div style=""text-align: center;"">a</div><div style=""text-align: justify;""><hr>Nada que comentar.</div>"
"<div style=""text-align: justify;"">Dado el siguiente algoritmo:</div><pre>// Precondición: i pertenece a {1,2,3}<br>hanoi(n,i,j) {<br>&nbsp;&nbsp;si n=1 entonces escribe “Mover de “ i “hasta” j<br>&nbsp;&nbsp;sino {<br>&nbsp;&nbsp;&nbsp;&nbsp;hanoi(n-1, i , 6-i-j)<br>&nbsp;&nbsp;&nbsp;&nbsp;hanoi(1 , i , j)<br>&nbsp;&nbsp;&nbsp;&nbsp;hanoi(n-1, 6-i-j, j)<br>&nbsp;&nbsp;}<br>}</pre><div style=""text-align: justify;"">El coste asintótico temporal pertenece al orden:</div><ol type=""a""><li>\(O(n^2)\)</li><li>\(O(\log^2 n)\)</li><li>\(O(2^n)\)</li><li>\(O(2^n)\)</li></ol>"	"<div style=""text-align: center;"">d</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">La base de la recursión es\(n=1\), que solo realiza una operación de escritura. La parte recursiva decrementa el tamaño del problema reduciendo el tamaño de los índices mediante restas. Podemos inferir que el tipo de recursión es aritmética. La relación de este tipo de recurrencia es \[T(n) =\begin{cases} cn^{k} &amp; \text{si } 1\leq n &lt; b \\aT(n-b)+cn^{k} &amp; \text{si } n\geq b\end{cases}\] que en este caso sería \[T(n)=2T(n−1)+1\] donde:</div><ol type=""a""><li>\(T(n-1)\): Mover los \(n-1\) discos desde el poste inicial al poste auxiliar.</li><li>\(T(n-1)\): Mover los \(n-1\) discos desde el poste auxiliar al final.</li><li>1: Mover el disco \(n\) desde el poste inicial al final.</li>El coste temporal asintótico es por tanto \(O(n^{2})\).</ol></div>"
"<div style=""text-align: justify;"">Indique cuál de las siguientes afirmaciones con respecto a los grafos es falsa:</div><ol type=""a""><li style=""text-align: justify;"">Se denomina componente conexa de un grafo a un subgrafo conexo maximal.</li><li style=""text-align: justify;"">La longitud de un camino es el número de aristas que contiene.</li><li style=""text-align: justify;"">Un grafo es simple si entre cada par de vértices existe a lo sumo una arista.</li><li style=""text-align: justify;"">Un grafo dirigido es conexo si al reemplazar todas sus aristas dirigidas por aristas no dirigidas resulta un grafo conexo no dirigido.</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><ol type=""a""><li style=""text-align: justify;"">Cierta.  Una componente conexa es un subgrafo conexo maximal, es decir, un subgrafo conexo al que no se le pueden añadir más vértices sin perder su propiedad de conexidad. </li><li style=""text-align: justify;"">Cierta. </li><li style=""text-align: justify;"">Falsa. Un grafo es simple si entre cada par de vértices existe a lo sumo una arista y no hay bucles (aristas que conectan un vértice consigo mismo).</li><li style=""text-align: justify;"">Cierta.</li></ol></div>"
"<div style=""text-align: justify;"">En el problema de colorear un grafo con&nbsp;\(n\) nodos utilizando \(m\) colores, de manera que no haya dos vértices adyacentes que tengan el mismo color, una cota superior ajustada del coste de encontrar una solución utilizando un esquema adecuado es del orden de:</div><ol type=""a""><li>\(O(n^m n)\)</li><li>\(O(m^{n})\)</li><li>\(O(\frac{n^m}{2} \log n)\)</li><li>\(O(m \log n)\)</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Cada vértice tendrá que ser considerado para colorearse con cada uno de los&nbsp;\(m\) colores. Por eso el coste es \(O(m^{n})\).</div></div>"
"<div style=""text-align: justify;"">Un peluquero pretende dar servicio a&nbsp;\(n\) clientes y conoce el tiempo requerido por cada uno de ellos, siendo \(t_i\), \(i = 1,2,\ldots,n\) el tiempo requerido por el cliente \(i\). El objetivo es minimizar el tiempo total que todos los clientes están en el sistema, y como el número de clientes es fijo, minimizar la espera total equivale a minimizar la espera media. ¿Cuál de los siguientes esquemas es más eficiente de los que puedan resolver el problema correctamente?</div><ol type=""a""><li>Esquema de ramificación y poda.</li><li>Esquema de vuelta atrás.</li><li>Esquema voraz.</li><li>Esquema de programación dinámica.</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">El problema es similar al de la planificación de&nbsp;\(n\) trabajos. El esquema más apropiado es el voraz, que ordenaría a los clientes por orden creciente de tiempo requerido y luego se atenderían en ese orden. EL coste sería \(O(n \log{n})\) respecto el número de clientes.</div></div>"
"<div style=""text-align: justify;"">¿Cuál de las siguientes afirmaciones es falsa con respecto al coste de las funciones de manipulación de grafos?</div><ol type=""a""><li style=""text-align: justify;"">La función BorrarArista es menos costosa cuando el grafo se implementa mediante una matriz de adyacencia.</li><li style=""text-align: justify;"">La función AñadirVertice que añade un vértice a un grafo y devuelve el grafo con dicho vértice incluido, tiene un coste constante cuando el grafo se implementa con una matriz de adyacencia.</li><li style=""text-align: justify;"">La operación Adyacente?, que comprueba si dos nodos son adyacentes, es más costosa cuando el grafo se implementa con una lista de adyacencia.</li><li style=""text-align: justify;"">La función Adyacentes, que devuelve una lista con los vértices adyacentes a uno dado, es más costosa cuando el grafo se implementa con una matriz de adyacencia.</li></ol>"	"<div style=""text-align: center;"">d</div><div style=""text-align: justify;""><hr>Nada que comentar.</div>"
"<div style=""text-align: justify;"">Una filmoteca ha organizado un maratón de cine de terror. Durante 24 horas se proyectarán películas (todas diferentes) en las&nbsp;\( n \) salas disponibles. Un aficionado a este género de películas ha conseguido la programación completa donde aparecen todas las películas que se van a proyectar durante el maratón. Junto con el título, nombre del director, duración de la película y otros datos de interés, se indica la sala de proyección y la hora de comienzo. Indique qué tipo de algoritmo de entre los siguientes sería el más eficiente para el aficionado planifique su maratón de cine, teniendo en cuenta que su único objetivo es ver el máximo número de posible de películas:</div><ol type=""a""><li>Esquema de ramificación y poda.</li><li>Esquema voraz.</li><li>Esquema divide y vencerás.</li><li>Esquema de vuelta atrás.</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Las salas pueden ordenarse por tiempo de finalización forma creciente. Luego solo habría que recorrer la secuencia seleccionando la sala mientras que su tiempo no se solape con la de la anterior. El esquema más apropiado, por tanto, es el voraz.</div></div>"
"<div style=""text-align: justify;"">Un dentista pretende dar servicio a&nbsp;\( n \) pacientes y conoce el tiempo requerido por cada uno de ellos, siendo \( t_i \), \( i = 1, 2, \ldots, n \), el tiempo requerido por el paciente \( i \). El objetivo es minimizar el tiempo total que todos los clientes están en el sistema, y como el número de pacientes es fijo, minimizar la espera total equivale a minimizar la espera media. ¿Cuál de los siguientes esquemas es más eficiente de los que puedan resolver el problema correctamente?</div><ol type=""a""><li>Esquema de vuelta atrás.</li><li>Esquema voraz.</li><li>Esquema de programación dinámica.</li><li>Esquema de ramificación y poda.</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">El tiempo medio de espera se minimiza seleccionando a los pacientes por orden creciente de tiempo de espera. Solo hay que ordenar la secuencia inicial en tiempo&nbsp;\(O(n \log{n})\) y luego atenderlos en ese orden. El esquema más apropiado, por tanto, es el voraz.</div></div>"
"<div style=""text-align: justify;"">Respecto a la estructura de datos montículo de mínimos, cuál de las siguientes afirmaciones es falsa:</div><ol type=""a""><li style=""text-align: justify;"">Con un montículo disponemos de una estructura de datos en la que encontrar el mínimo es una operación de coste constante.</li><li style=""text-align: justify;"">El montículo sirve de apoyo a la creación de un algoritmo de ordenación eficiente conocido como Heapsort.</li><li style=""text-align: justify;"">El montículo es un árbol binario que puede estar o no balanceado.</li><li style=""text-align: justify;""><div style=""text-align: justify;"">Cuando se extrae el primer elemento de un montículo, restaurar la propiedad de montículo tiene coste&nbsp;\( O(\log n) \).</div></li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr>Nada que comentar.</div>"
"<div style=""text-align: justify;"">Sobre el algoritmo de Dijkstra, cuál de las siguientes afirmaciones es falsa:</div><ol type=""a""><li style=""text-align: justify;"">El algoritmo de Dijkstra determina la longitud del camino de coste, peso o distancia mínima que va desde el nodo origen a cada uno de los demás nodos del grafo.</li><li style=""text-align: justify;"">El algoritmo de Dijkstra sigue el esquema voraz.</li><li style=""text-align: justify;""><div style=""text-align: justify;"">El coste del algoritmo de Dijkstra es&nbsp;\( O(n \log n) \).</div></li><li style=""text-align: justify;"">En el algoritmo de Dijkstra un camino desde el nodo origen hasta otro nodo es especial si se conoce el camino de coste mínimo desde el nodo origen a todos los nodos intermedios.</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">El coste no siempre es&nbsp;\(O(n \log{n})\). En caso de: no usar un montículo; \(O(n^{2})\), usar un montículo y que el grafo sea denso; \(O(n^{2} \log{n})\), y en caso de usar un montículo y que el grafo sea disperso; \(O(n \log{n})\).</div></div>"
"<div style=""text-align: justify;"">Sea el problema de la mochila, en el que tenemos una mochila de capacidad&nbsp;\( M \), y \( n \) objetos con beneficios \( b_1, b_2, b_3, \ldots, b_n \) y pesos \( p_1, p_2, p_3, \ldots, p_n \). El objetivo es maximizar el valor de los objetos transportados, respetando la limitación de la capacidad impuesta \( M \). Indica, de los esquemas siguientes, cuál es el más adecuado en el caso de que cada objeto pueda meterse en la mochila entero o fraccionado.</div><ol type=""a""><li>El esquema de ramificación y poda.</li><li>El esquema voraz.</li><li>El esquema divide y vencerás.</li><li>El esquema de vuelta atrás.</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Debido a que los objetos pueden fraccionarse, el esquema más apropiado es el voraz. Si no lo fueran, el esquema de programación dinámica suele ser mejor que el de ramificación y poda.&nbsp;</div></div>"
"<div style=""text-align: justify;"">Indica cuál de las siguientes afirmaciones es cierta con respecto al problema de la devolución de cambio de moneda utilizando un número mínimo de monedas y suponiendo que la disponibilidad de cada tipo de moneda es ilimitada:</div><ol type=""a""><li style=""text-align: justify;"">El problema de la devolución de cambio de moneda para cualquier sistema monetario, siempre que en el sistema se disponga de un tipo de moneda de 1, se puede resolver utilizando el esquema de programación dinámica pero no el de ramificación y poda.</li><li style=""text-align: justify;"">El problema de la devolución de cambio de moneda para cualquier sistema monetario, siempre que en el sistema se disponga de un tipo de moneda de 1, se puede resolver utilizando los esquemas de programación dinámica y de ramificación y poda.</li><li style=""text-align: justify;"">El problema de la devolución de cambio de moneda se puede resolver para todo sistema monetario utilizando una estrategia voraz, siempre que en el sistema se disponga de un tipo de moneda de 1.</li><li style=""text-align: justify;""><div style=""text-align: justify;"">Si se dispone de&nbsp;\( n \) tipos de moneda \( T = \{m_0, m_1, m_2, \ldots, m_{n-1}\} \) siendo \( m &gt; 1 \) y \( n &gt; 0 \), el problema de la devolución de cambio de moneda no se puede resolver utilizando una estrategia voraz.</div></li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">La existencia de una moneda de coste 1 garantiza que tanto programación dinámica como ramificación y poda siempre encuentren una solución óptima para cualquier cantidad&nbsp;\(C\).</div></div>"
"<div style=""text-align: justify;"">Indica cuál de las siguientes afirmaciones es cierta con respecto al algoritmo Quicksort para un vector de tamaño&nbsp;\( n \).</div><ol type=""a""><li>Ninguna de las otras opciones es cierta.</li><li>Se compone de dos invocaciones recursivas con tamaño \( n/2 \) más un procedimiento que combina los subvectores ordenados resultantes que es de coste lineal.</li><li>Su coste en el caso peor es \( O(n^2) \), pero existe una versión mejorada eligiendo como pivote la mediana del vector, lo que daría que el coste del Quicksort en el caso peor sería \( O(n) \).</li><li>Está compuesto de dos recorridos lineales del vector y posteriormente una llamada recursiva al subvector no ordenado.</li></ol>"	"<div style=""text-align: center;"">a</div><div style=""text-align: justify;""><hr><ol type=""a""><li style=""text-align: justify;"">Cierta. </li><li style=""text-align: justify;""><div style=""text-align: justify;"">Falsa. Quicksort no garantiza que los tamaños de los subproblemas sean&nbsp;\(n/2\) porque depende de la posición del pivote; por lo que el tamaño de los subproblemas pueden estar desequilibrados. Por otra parte, la combinación se realiza implícitamente al completar las recursiones.</div></li><li style=""text-align: justify;""><div style=""text-align: justify;"">Falsa. Eligiendo el pivote se mejora el coste a&nbsp;\(O(n \log{n})\) en el peor de los casos.</div></li><li style=""text-align: justify;"">Falsa. Divide el vector en dos mitades y hace una llamada a cada una.</li></ol></div>"
"<div style=""text-align: justify;"">Dos socios que conforman una sociedad comercial deciden disolverla. Cada uno de los&nbsp;\( n \) activos que hay que repartir tiene un valor entero positivo. Los socios quieren repartir dichos activos a medias y, para ello, primero quieren comprobar si el conjunto de activos se puede dividir en dos subconjuntos disjuntos, de forma que cada uno de ellos tenga el mismo valor. ¿Cuál de los siguientes esquemas de los que puedan resolver el problema correctamente es más eficiente?</div><ol type=""a""><li>Esquema de vuelta atrás.</li><li>Esquema voraz.</li><li>Esquema de divide y vencerás.</li><li>Esquema de ramificación y poda.</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">El problema es conocido como el problema de la partición de conjuntos, y el esquema más eficiente para resolverlo es programación dinámica.</div></div>"
"<div style=""text-align: justify;"">Considérese el vector&nbsp;\( v[1..n] = [2, 3, 5, 3, 4, 5, 7, 5, 6] \). Indica cuál de las siguientes opciones es cierta:</div><ol type=""a""><li>Ninguna de las otras opciones.</li><li>El vector \( v \) no es un montículo de mínimos porque el elemento \( v[5] = 4 \) debe ser flotado.</li><li>El vector \( v \) es un montículo de mínimos.</li><li>El vector \( v \) no es un montículo de máximos porque el elemento \( v[5] = 4 \) debe ser hundido.</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Si se dibuja, se ve que cumple ser un montículo de mínimos porque cada nodo tiene como hijos nodos que son iguales o menores que él.</div></div>"
"<div style=""text-align: justify;"">Para resolver determinado problema hemos diseñado un algoritmo de tipo divide y vencerás. ¿Cuál de las siguientes afirmaciones es falsa?</div><ol type=""a""><li style=""text-align: justify;"">El algoritmo de la búsqueda binaria aplica la estrategia divide y vencerás.</li><li style=""text-align: justify;"">Los algoritmos basados en este esquema pueden requerir un paso de combinación de las soluciones parciales.</li><li style=""text-align: justify;"">La resolución debe alcanzar un caso trivial que se pueda resolver sin realizar nuevas descomposiciones.</li><li style=""text-align: justify;"">El problema se resuelve por divisiones sucesivas en subproblemas, que pueden ser de mayor o de menor tamaño que el de partida.</li></ol>"	"<div style=""text-align: center;"">d</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">La división en sucesivos subproblemas deben ser de tamaño menor que el de partida.</div></div>"
"<div style=""text-align: justify;"">Se quiere realizar una recopilación de poesías preferidas en un rollo de papel que se puede escribir por ambas caras. Se dispone de una lista de&nbsp;\( n \) poesías favoritas, junto con la longitud individual de cada una. Lamentablemente, el rollo de longitud \( L \) no tiene capacidad para contener todas las poesías, por lo que se les ha asignado una puntuación (cuanto más favorita es, mayor es la puntuación). Se pretende obtener el mejor rollo posible según la puntuación, teniendo en cuenta que las poesías deben caber enteras y no es admisible que una poesía se corte al final de una de las caras. ¿Cuál de los siguientes esquemas es más eficiente de los que puedan resolver el problema correctamente?</div><ol type=""a""><li>Esquema voraz.</li><li>Esquema divide y vencerás.</li><li>Esquema de vuelta atrás.</li><li>Esquema de ramificación y poda.</li></ol>"	"<div style=""text-align: center;"">a</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">La secuencia de poesías puede ordenarse de forma decreciente por puntuación usando un montículo y luego recorrerla seleccionando la poesía siempre que haya espacio para la misma en el rollo. Por tanto el esquema más apropiado es el voraz.&nbsp;</div><div style=""text-align: justify;""><br></div><div style=""text-align: justify;"">El coste tanto de ordenarla como del posterior recorrido sería&nbsp;\(O(n)\), por lo que el coste total sería \(O(2n)\) que puede despreciarse en \(O(n)\).&nbsp;</div></div>"
"<div style=""text-align: justify;"">Una empresa de montajes tiene&nbsp;\( n \) montadores con distintos rendimientos según el tipo de trabajo. Se trata de asignar los próximos \( n \) encargos, uno a cada montador, minimizando el coste total de todos los montajes. Para ello se conoce de antemano la tabla de costes \( C[1..n, 1..n] \) en la que el valor \( c_{ij} \) corresponde al coste de que el montador \( i \) realice el montaje \( j \). ¿Cuál de los siguientes esquemas es más eficiente de los que puedan resolver el problema correctamente?</div><ol type=""a""><li>Esquema de ramificación y poda.</li><li>Esquema voraz.</li><li>Esquema divide y vencerás.</li><li>Esquema de vuelta atrás.</li></ol>"	"<div style=""text-align: center;"">a</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">El problema es de minimización respecto el coste total de los montajes. Dado que no se conoce una función para seleccionar eficiente y localmente el montador a su respectivo montaje, el esquema apropiado sería ramificación y poda.&nbsp;</div></div>"
"<div style=""text-align: justify;"">Dado el grafo no dirigido de la figura, la aplicación del algoritmo de cálculo de los puntos de articulación (y de su árbol de recubrimiento asociado) da como resultado el vector&nbsp;\( \text{bajo[]} \) siguiente:&nbsp;</div><img src=""uned-preda_01.png""><br> <ol type=""a""><li>Ninguna de las otras opciones</li><li>[1,3,3,1,1,3,3]</li><li>[1,1,3,1,5,5,5]</li><li>[1,2,3,4,1,6,7]</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Los nodos 1, 2 y 5 son puntos de articulación porque si se eliminan el grafo deja de ser conexo. Para encontrar el árbol de recubrimiento mínimo puede usarse Prim o Kruskal. El vector solución no es único porque depende del recorrido que haga el algoritmo y del nodo inicial escogido; luego se tiene que identificar de las opciones aquella que se corresponda con una de las posibles soluciones.&nbsp;</div><div style=""text-align: justify;""><br></div><div style=""text-align: justify;"">En los vectores propuestos por el problema, cada par de nodos se corresponde con una arista del posible árbol de recubrimiento mínimo, de forma que en la opción&nbsp;\(b\) (1,3) es la primera arista, (3,3) es la segunda, (3,1) es la tercera, (1,1) la cuarta, (1,3) la quinta y (3,3) la sexta. De esto se concluye que la opción cierta es la \(a\) porque todos los vectores tienen aristas que no pertenecen al grafo y que por tanto es imposible que estén en un hipotético árbol de recubrimiento mínimo.</div></div>"
"<div style=""text-align: justify;"">Sea el problema de la mochila en su versión de objetos no fraccionables solucionado con programación dinámica. Supongamos que se dispone de 5 objetos con pesos: 1,3,4,5,7 y beneficios: 2,5,10,14,15 respectivamente, y un volumen máximo de 8. Identifica cuál de las siguientes respuestas correspondería al contenido de la tabla de resultados parciales en la fila correspondiente al objeto de peso 5, si dichos objetos se consideran en orden creciente de pesos.</div><ol type=""a""><li style=""text-align: justify;"">0 2 2 5 10 12 14 16 19</li><li style=""text-align: justify;"">0 2 2 5 10 14 16 16 19</li><li style=""text-align: justify;"">0 2 2 5 10 12 12 15 15</li><li style=""text-align: justify;"">Ninguna de las otras opciones</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">El eje de ordenadas de la tabla representa un objeto concreto mientras que el de abscisas representa, en el caso de la primera fila; un volumen a rellenar usando los objetos disponibles, y el resto de filas representa el beneficio máximo de usar los objetos. No se indica de forma explícita los objetos usados para cubrir un volumen pero si el beneficio máximo que se consigue para un volumen concreto.</div><div style=""text-align: justify;"">No se puede reutilizar un objeto; cada uno de los 5 solo puede usarse una vez. Sabiendo esto, la tabla debe ser rellenada empezando desde la fila superior hasta la inferior. La tabla quedaría de la siguiente forma:</div> <table><tbody><tr><th>Objeto</th><th>Volumen 0</th><th>Volumen 1</th><th>Volumen 2</th><th>Volumen 3</th><th>Volumen 4</th><th>Volumen 5</th><th>Volumen 6</th><th>Volumen 7</th><th>Volumen 8</th></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>3</td><td>0</td><td>2</td><td>2</td><td>5</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td></tr><tr><td>4</td><td>0</td><td>2</td><td>2</td><td>5</td><td>10</td><td>12</td><td>12</td><td>15</td><td>17</td></tr><tr><td>5</td><td>0</td><td>2</td><td>2</td><td>5</td><td>10</td><td>14</td><td>16</td><td>16</td><td>19</td></tr><tr><td>7</td><td>0</td><td>2</td><td>2</td><td>5</td><td>10</td><td>14</td><td>16</td><td>16</td><td>17</td></tr></tbody></table></div>"
"<div style=""text-align: justify;"">Dado el siguiente grafo dirigido: Se pide detallar el valor del vector de distancias especial[] en el paso del algoritmo de Dijkstra en el que se selecciona el nodo&nbsp;\(v=7\), tomando como nodo origen el nodo 1.&nbsp;</div><img src=""uned-preda_02.png""><br> <ol type=""a""><li>\([10,\infty,\infty,6,\infty,\infty]\)</li><li>\([10,\infty,\infty,6,15,7]\)</li><li>\([10,15,12,6,15,7]\)</li><li>Ninguna de las otras opciones</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Nota: las opciones propuestas no tienen en cuenta el nodo inicial, cuya distancia siempre va a ser cero. Por lo tanto, el vector empieza por la distancia del nodo 2. A continuación, se enumeran los primeros pasos que haría el algoritmo:</div> <ul> <li>Inicialización:</li> <ul> <li>Nodo origen: 1.</li> <li>Vector de distancias inicial: \([0,\infty ,\infty ,\infty ,\infty ,\infty ,\infty ]\)</li> <li>Conjunto de nodos visitados:\(\emptyset\).</li> <li>Conjunto de nodos no visitados: {1,2,3,4,5,6,7} </li> </ul> <li>Selección del nodo inicial(Nodo 1):</li> <ul> <li>Actualizar las distancias de los vecinos del nodo 1:</li> <ul> <li>\(dist[2] = min(\infty, 10) = 10\)</li> <li>\(dist[4] = min(\infty, \infty) = \infty\)</li> <li>\(dist[5] = min(\infty, 6) = 6\)</li> </ul> <li>Vector de distancias: \([0,10 ,\infty ,\infty ,6 ,\infty ,\infty ]\)</li> <li>Nodo 1 se añade al conjunto de nodos visitados.</li> </ul> <li>Selección del nodo más cercano (Nodo 5):</li> <ul> <li>Actualizar las distancias de los vecinos del nodo 5:</li> <ul> <li>\(dist[6] = min(\infty, 6+9) = 15\)</li> <li>\(dist[7] = min(\infty, 6+1) = 7\)</li> </ul> <li>Vector de distancias: \([0,10,\infty,\infty,6,15,7]\)</li> <li>Nodo 5 se añade al conjunto de nodos visitados.</li> </ul> <li>Selección del nodo más cercano (Nodo 7):</li> <ul> <li>El nodo 7 no tiene aristas dirigidas a otro nodo luego no hay actualizaciones.</li> <li>Nodo 7 se añade al conjunto de nodos visitados.</li> </ul> <li>Selección del nodo más cercano (Nodo 6):</li> <ul> <li>Actualizar las distancias de los vecinos del nodo 6:</li> <ul> <li>\(dist[3] = min(\infty, 15+2) = 17\)</li> <li>\(dist[4] = min(\infty, 15+3) = 18\)</li> <li>\(dist[7] = min(7, 15+8) = 7\)</li> </ul> <li>Vector de distancias: \([0,10,17,18,6,15,7]\)</li> <li>Nodo 6 se añade al conjunto de nodos visitados.</li></ul></ul> De esta forma se continuaría con el resto de nodos y se verificaría que la respuesta es la \(c\).</div>"
"<div style=""text-align: justify;"">En un problema de mochila con objetos fraccionables tenemos&nbsp;\( n = 8 \) objetos disponibles. Los pesos de los objetos son \( w = (8, 7, 6, 5, 4, 3, 2, 1) \) y los beneficios son \( v = (10, 9, 8, 7, 6, 5, 4, 3) \). ¿Cuál es el beneficio óptimo para este ejemplo, suponiendo que la capacidad de la mochila es \( M = 9 \)?</div><ol type=""a""><li>Ninguna de las otras respuestas es correcta.</li><li>12</li><li>15</li><li>16.5</li></ol>"	"<div style=""text-align: center;"">d</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Dado que los objetos son fraccionables, el problema puede resolverse mediante un esquema voraz.</div><div style=""text-align: justify;"">El procedimiento consiste en dividir el beneficio de cada objeto por su peso, ordenar la secuencia resultante de forma decreciente y recorrerla seleccionando el objeto asociado al beneficio/peso actual siempre que quepa en la mochila. Si el objeto actual no cabe, se fracciona, se añade el beneficio correspondiente a la solución y se devuelve la misma.&nbsp;</div><div style=""text-align: justify;""><br></div><div style=""text-align: justify;"">Para este ejercicio concreto la relación beneficio/peso es la siguiente:</div>\[\frac{v_i}{w_i} = \left( \frac{10}{8}, \frac{9}{7}, \frac{8}{6}, \frac{7}{5}, \frac{6}{4}, \frac{5}{3}, \frac{4}{2}, \frac{3}{1} \right) = \left( 1.25, 1.2857, 1.3333, 1.4, 1.5, 1.6667, 2, 3 \right)\]<div style=""text-align: justify;"">&nbsp;</div><div style=""text-align: justify;"">La secuencia ordenada:</div><div style=""text-align: justify;"">\[\left(3,2,1.6667,1.5,1.4,1.3333,1.2857,1.25\right)\]</div><div style=""text-align: justify;"">corresponde a los objetos&nbsp;\(\left(1,2,3,4,5,6,7,8\right)\).&nbsp;</div><div style=""text-align: justify;""><br></div>Podemos meter a la mochila el objeto 1, 2 y 3 sin fraccionar. El beneficio hasta el momento es de 12 y el peso ocupado es de 6, teniendo 3 de espacio restante. En el cuarto objeto solo podemos tomar una fracción. Dado que el espacio restante es 3 y el peso del objeto es 4, la fracción que tomamos es \[4\left(\text{peso del objeto}\right)*\frac{3}{4}=3\left(\text{peso restante}\right)\rightarrow \frac{3}{4}\]Dado que el beneficio del objeto es de 6 entonces el beneficio del objeto fraccionado es&nbsp;\(6*\frac{3}{4}=4.5\). Sumado a los 12 que teníamos da 16.5, con una capacidad restante en la mochila de 0. </div>"
"<div style=""text-align: justify;"">Considérese el vector&nbsp;\( v[1..n] = [6,5,5,2,5,5,3,2,2] \) cuál de las siguientes opciones es cierta:</div><ol type=""a""><li>El vector \( v \) no es un montículo de máximos porque el elemento \( v[4] = 2 \) debe ser flotado.</li><li>El vector \( v \) es un montículo de máximos.</li><li>El vector \( v \) no es un montículo de máximos porque el elemento \( v[4] = 2 \) debe ser hundido.</li><li>Ninguna de las otras opciones</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Un dibujo rápido del montículo muestra que efectivamente es de máximos porque todos los nodos cumplen ser igual o mayor que todos sus hijos.</div></div>"
"<div style=""text-align: justify;"">Identifique cuál de las siguientes secuencias de código implementa un recorrido en anchura de una componente conexa de un grafo:</div><ol type=""a""><li><pre>fun RecAnchura(v: nodo, visitado: Vector)<br>&nbsp;&nbsp;var<br>&nbsp;&nbsp;&nbsp;&nbsp;u,w: nodo<br>&nbsp;&nbsp;&nbsp;&nbsp;Q: TCola<br>&nbsp;&nbsp;fvar<br>&nbsp;&nbsp;Q ← ColaVacía<br>&nbsp;&nbsp;visitado[v] ← cierto<br>&nbsp;&nbsp;Encolar(v,Q)<br>&nbsp;&nbsp;mientras ¬ vacia(Q) hacer<br>&nbsp;&nbsp;&nbsp;&nbsp;u ← Primero(Q)<br>&nbsp;&nbsp;&nbsp;&nbsp;Desencolar(u,Q)<br>&nbsp;&nbsp;&nbsp;&nbsp;para cada w adyacente a u hacer<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;si ¬ visitado[w] entonces<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visitado[w] ← cierto<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Encolar(w,Q)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fsi<br>&nbsp;&nbsp;&nbsp;&nbsp;fpara<br>&nbsp;&nbsp;fmientras<br>ffun</pre></li><li><pre>fun RecAnchura(v: nodo, visitado: Vector)<br>&nbsp;&nbsp;var<br>&nbsp;&nbsp;&nbsp;&nbsp;u,w: nodo<br>&nbsp;&nbsp;&nbsp;&nbsp;Q: TCola<br>&nbsp;&nbsp;fvar<br>&nbsp;&nbsp;Q ← ColaVacía<br>&nbsp;&nbsp;Encolar(v,Q)<br>&nbsp;&nbsp;mientras ¬ vacia(Q) hacer<br>&nbsp;&nbsp;&nbsp;&nbsp;visitado[v] ← cierto<br>&nbsp;&nbsp;&nbsp;&nbsp;u ← Primero(Q)<br>&nbsp;&nbsp;&nbsp;&nbsp;Desencolar(u,Q)<br>&nbsp;&nbsp;&nbsp;&nbsp;para cada w adyacente a u hacer<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;si ¬ visitado[w] entonces<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visitado[w] ← cierto<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fsi<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Encolar(w,Q)<br>&nbsp;&nbsp;&nbsp;&nbsp;fpara<br>&nbsp;&nbsp;fmientras<br>ffun</pre></li><li><pre>fun RecAnchura(v: nodo, visitado: Vector)<br>&nbsp;&nbsp;var<br>&nbsp;&nbsp;&nbsp;&nbsp;u,w: nodo<br>&nbsp;&nbsp;&nbsp;&nbsp;Q: TCola<br>&nbsp;&nbsp;fvar<br>&nbsp;&nbsp;Q ← ColaVacía<br>&nbsp;&nbsp;visitado[v] ← cierto<br>&nbsp;&nbsp;Encolar(v,Q)<br>&nbsp;&nbsp;&nbsp;&nbsp;u ← Primero(Q)<br>&nbsp;&nbsp;mientras ¬ vacia(Q) hacer<br>&nbsp;&nbsp;&nbsp;&nbsp;Desencolar(u,Q)<br>&nbsp;&nbsp;&nbsp;&nbsp;para cada w adyacente a u hacer<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;si ¬ visitado[w] entonces<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Encolar(w,Q)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fsi<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visitado[w] ← cierto<br>&nbsp;&nbsp;&nbsp;&nbsp;fpara<br>&nbsp;&nbsp;fmientras<br>ffun</pre></li><li>Ninguna de las otras secuencias es correcta.</li></ol>"	"<div style=""text-align: center;"">a</div><div style=""text-align: justify;""><hr><ol type=""a""><li style=""text-align: justify;"">Cierta.</li><li style=""text-align: justify;""><div style=""text-align: justify;"">La variable&nbsp;\(v\) se usa dentro del bucle pero no parece que se actualice en ningún momento; siempre almacena el nodo raíz.</div></li><li style=""text-align: justify;""><div style=""text-align: justify;"">No se entra en el bucle porque la cola&nbsp;\(Q\) se vacía antes de entrar al bucle.</div></li><li style=""text-align: justify;""><div style=""text-align: justify;"">La&nbsp;\(a\) es cierta.</div></li></ol></div>"
"<div style=""text-align: justify;"">¿Cuántos componentes fuertemente conexos existen en el grafo de la siguiente figura?&nbsp;</div><div style=""text-align: justify;""><br></div><div style=""text-align: justify;""><img src=""uned-preda_03.png""></div> <ol type=""a""><li style=""text-align: justify;"">Más de tres.</li><li style=""text-align: justify;"">Tres.</li><li style=""text-align: justify;"">Dos.</li><li style=""text-align: justify;"">Uno solo, formado por todo el grafo.</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Un componente fuertemente conexo de un grafo dirigido es un subgrafo en el cual existe un camino dirigido entre cada par de nodos: para cualquier par de nodos&nbsp;\(u\) y \(v\) dentro del componente, hay un camino dirigido de \(u\) a \(v\) y un camino dirigido de \(v\) a \(u\). Se identifican las siguientes componentes fuertemente conexas:</div><ul><li>{c,e}</li><li>{a,b,d}</li><li>{f,g,h}</li></ul> En los últimos dos componentes, es importante comentar que cumplen serlo porque dado cualquier par de nodos que cojamos de los 3, hay un camino en ese componente que permite ir de uno al otro y viceversa.</div>"
"<div style=""text-align: justify;"">Dado el grafo no dirigido de la figura, indique cuál sería el orden en que se seleccionarían (pasan a pertenecer al árbol) los nodos al aplicar el algoritmo de Prim comenzando por el nodo&nbsp;\(A\):</div><div style=""text-align: justify;""><br></div><img src=""uned-preda_04.png""><br> <ol type=""a""><li>\(A, F, E, C, B, D\)</li><li>\(A, B, C, E, D, F\)</li><li>\(A, C, D, B, F, E\)</li><li>Ninguna de las otras opciones</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Sea:</div><ul><li style=""text-align: justify;""><div style=""text-align: justify;""> \(M\) el árbol de recubrimiento mínimo del problema (es decir, la solución del problema, que empieza vacía).</div></li><li style=""text-align: justify;""><div style=""text-align: justify;""> \(O\) el conjunto de nodos seleccionados de forma que \(O \subseteq M\). Inicialmente añadimos un nodo cualquiera a \(M\) como raíz.</div></li></ul><div style=""text-align: justify;"">En cada paso se añade a </div><div style=""text-align: justify;""> </div>\(M\) una arista de coste mínimo \(u, v\) tal que \(M \cup \left\{\left( u,v\right)\right\}\) sea también un árbol. El algoritmo continúa hasta que \(M\) tiene \(n-1\) aristas. La arista \(\left(u,v\right)\) se selecciona en cada paso de forma que \(u\) o \(v\) esté en \(M\) (la otra podría estar en el grafo del problema).<br><br> Teniendo en cuenta esto:<br><ol type=""a""><li>Falso.\(A \cup F\) no es un árbol.</li><li>Falso. \(C\) tendría que ir antes de \(B\) porque su arista es de menor peso. </li><li>Cierta.</li><li>La \(c\) es cierta.</li></ol></div>"
"<div style=""text-align: justify;"">Dado el vector&nbsp;\( v = [5,6,9,3,4,1] \) y el algoritmo Quicksort, los vectores argumento de la primera invocación recursiva, con pivote \( v[1] = 5 \), son:</div><ol type=""a""><li>[5,6,9] y [5,3,4,1]</li><li>[3,4,1] y [6,9]</li><li>[5] y [6,9,3,4,1]</li><li>[1] y [5,6,9,3,4]</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">El algoritmo toma los elementos mayores que el pivote y forma un subvector; procede forma análoga con los elementos menores. Luego realiza una llamada recursiva al algoritmo con cada subvector. La&nbsp;\(a\) no es cierta porque ningún subvector debería contener al pivote.</div></div>"
"<div style=""text-align: justify;"">Considérese el vector [10,7,7,4,3,1] que representa un montículo. ¿Cuál sería la representación resultante de insertar en este montículo el valor 11 usando la función flotar?</div><ol type=""a""><li style=""text-align: justify;"">[10,7,11,4,3,1,7].</li><li style=""text-align: justify;"">[11,7,7,4,3,1,10].</li><li style=""text-align: justify;"">[10,7,11,4,3,1,7].</li><li style=""text-align: justify;"">Ninguna de las otras opciones</li></ol>"	"<div style=""text-align: center;"">d</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Se observa que el montículo es de máximos porque todos los nodos cumplen ser mayor o igual que cualquiera de sus hijos. La&nbsp;\(a\) y la \(c\) no son ciertas porque el 11 no está en la cima del montículo. La \(b\) tampoco es cierta porque el 10 queda como hijo de \(v[2]=7\) (empezando a contar por el cero) y por tanto ya no cumple ser montículo.</div></div>"
"<div style=""text-align: justify;"">Dado el siguiente montículo de mínimos cuál de los siguientes vectores lo representa de forma correcta:</div><div style=""text-align: justify;""><br></div><div style=""text-align: justify;""><img src=""uned-preda_05.png""></div><ol type=""a""><li style=""text-align: justify;"">El montículo propuesto es un montículo de máximos y no de mínimos.</li><li style=""text-align: justify;"">[3,9,5,10,9,6].</li><li style=""text-align: justify;"">[10,9,9,6,5,3].</li><li style=""text-align: justify;"">[3,9,10,9,5,6].</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">El vector de un montículo siempre debe coincidir con un recorrido en altura de izquierda a derecha del árbol.</div></div>"
"<div style=""text-align: justify;"">Selecciona la afirmación más ajustada de las siguientes. Las siguientes tres figuras corresponden a:</div><div style=""text-align: justify;""><br></div><div style=""text-align: justify;""><img src=""uned-preda_06.png""></div><ol type=""a""><li style=""text-align: justify;"">Ninguna de las otras opciones es correcta.</li><li style=""text-align: justify;"">La de la izquierda es un grafo y a los grafos no dirigidos conexos con aristas de igual coste no se les puede asociar más de un árbol de recubrimiento mínimo.</li><li style=""text-align: justify;"">Las tres corresponden a tres grafos no dirigidos sin ninguna relación entre ellos.</li><li style=""text-align: justify;"">La de la izquierda es un grafo y las de la derecha son dos posibles árboles de recubrimiento mínimo asociados a él.</li></ol>"	"<div style=""text-align: center;"">d</div><div style=""text-align: justify;""><hr><ol type=""a""><li style=""text-align: justify;""><div style=""text-align: justify;"">Debería ser la&nbsp;\(d\).</div></li><li style=""text-align: justify;"">Es ambigua. Dice: ""los grafos no dirigidos conexos con aristas de igual coste no se les puede asociar más de un árbol de recubrimiento mínimo""; pudiendo referirse a los dos grafos en la parte derecha de la imagen o a cualquier grafo con las características descritas. Se marca como falsa pensando que es lo segundo.</li><li style=""text-align: justify;"">No es cierto ya que los grafos de la derecha técnicamente se corresponden con dos posibles árboles de recubrimiento del grafo de la izquierda.</li><li style=""text-align: justify;"">Cierta.</li></ol></div>"
"<div style=""text-align: justify;"">¿Cuántos componentes fuertemente conexos existen en el grafo de la siguiente figura?</div><div style=""text-align: justify;""><br></div><div style=""text-align: justify;""><img src=""uned-preda_07.png""></div><ol type=""a""><li style=""text-align: justify;"">Dos.</li><li style=""text-align: justify;"">Uno solo, formado por todo el grafo.</li><li style=""text-align: justify;"">Tres.</li><li style=""text-align: justify;"">Más de tres.</li></ol>"	"<div style=""text-align: center;"">a</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Un componente fuertemente conexo (SCC, Strongly Connected Component) es un conjunto de nodos del grafo donde cualquiera puede ser alcanzado por otro nodo del conjunto y viceversa. Un nodo individidual puede ser una SCC.</div><div style=""text-align: justify;""><br></div><div style=""text-align: justify;"">Se identifican las siguientes SCC:</div><ul><li style=""text-align: justify;"">{b,c} forman un ciclo.</li><li style=""text-align: justify;"">{a,e,d} forman otro ciclo</li></ul><div style=""text-align: justify;"">En total son dos SCC.</div></div>"
"<div style=""text-align: justify;"">Dado el grafo de la siguiente figura: indicar cuál sería el orden en que se seleccionarían (pasan a estar explorados) los nodos al aplicar el algoritmo de Dijkstra desde el nodo 1:</div><div style=""text-align: justify;""><br></div><div style=""text-align: justify;""><img src=""uned-preda_08.png""></div><ol type=""a""><li style=""text-align: justify;"">Ninguna de las otras opciones.</li><li style=""text-align: justify;"">1,2,4,5,3.</li><li style=""text-align: justify;"">1,2,5,4,3.</li><li style=""text-align: justify;"">1,2,3,5,4.</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr>Nada que comentar.</div>"
"<div style=""text-align: justify;"">Considérese el vector&nbsp;\(v=[2,6,8,12,7,5,4]\). ¿Cuál de las siguientes opciones es cierta?</div><ol type=""a""><li>El vector \(v\) es un montículo de mínimos.</li><li>\(v\) sería un montículo de mínimos si se flotara el elemento de valor 5.</li><li>\(v\) sería un montículo de mínimos si se hundiera el elemento de valor 8.</li><li>Ninguna de las otras opciones.</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;""> \(v\) no cumple ser un montículo de mínimos por la rama derecha de la raíz. Si se flota el elemento 5, seguiría sin serlo porque el elemento sería padre del nodo 4. La solución para arreglarlo es hundir el elemento 8.</div></div>"
"<div style=""text-align: justify;"">Sea el problema de la mochila en su versión de objetos no fraccionables solucionado mediante programación dinámica. Suponga que se dispone de 5 objetos con volúmenes&nbsp;\(\{1,2,5,6,7\}\) y que aportan unos beneficios de \(\{1,6,18,22,28\}\), respectivamente. Suponga también que dispone de una mochila con una capacidad máxima de 11. Indique cuál sería el contenido de la tabla de resultados parciales en la fila correspondiente al objeto de peso 7, si dichos objetos se consideran en orden creciente de pesos.</div><ol type=""a""><li>0 1 6 7 7 18 19 24 25 25 28 29</li><li>0 1 6 7 7 18 22 24 28 29 29 40</li><li>0 1 6 7 7 18 22 28 29 34 35 40</li><li>Ninguna de las otras opciones.</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">La tabla debe ser:</div><ul><li style=""text-align: justify;"">La fila más superior de los volúmenes a rellenar empezando por uno.</li><li style=""text-align: justify;"">La primera columna (la más a la izquierda) debería ser cada uno de los identificadores que le hayamos asignado a los objetos. Deberían estar ordenados crecientemente por volumen.</li></ul><div style=""text-align: justify;"">Hay que rellenar la tabla haciendo que para cada volumen a rellenar, se objenga el máximo beneficio posible usando el objeto de la fila actual sumado al beneficio de la fila anterior. Si el objeto no cabe (por peso) simplemente se vuelve a escribir el beneficio de la fila anterior. Es importante recordar que cada objeto solo puede ser usado una vez por columna.</div></div>"
"<div style=""text-align: justify;"">Dado el siguiente grafo dirigido: Indique el valor del vector de distancias especial[] en el paso del algoritmo de Dijkstra en el que se selecciona el nodo&nbsp;\(v=4\), tomando como nodo origen el nodo 1:</div><br><img src=""uned-preda_09.png""><br><ol type=""a""><li>Ninguna de las otras opciones.</li><li>\([50, 30,40, \infty]\)</li><li>\([\infty, 30,40, \infty]\)</li><li>\([55, 30,40, 80]\)</li></ol>"	"<div style=""text-align: center;"">d</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Nota: las opciones propuestas no tienen en cuenta el nodo inicial, cuya distancia siempre va a ser cero. Por lo tanto, el vector empieza por la distancia del nodo 2. A continuación, se enumeran los primeros pasos que haría el algoritmo:</div><ul><li>Inicialización:</li> <ul><li>Nodo origen: 1.</li> <li>Vector de distancias inicial: \([0,\infty ,\infty ,\infty ,\infty ,\infty ,\infty ]\)</li> <li>Conjunto de nodos visitados: \(\emptyset\).</li> <li>Conjunto de nodos no visitados: {1,2,3,4,5}</li> </ul> <li>Selección del nodo inicial (Nodo 1):</li> <ul><li>Actualizar las distancias de los vecinos del nodo 1:</li> <ul><li>\(dist[2] = \min(\infty, 100) = 100\)</li> <li>\(dist[3] = \min(\infty, 30) = 30\)</li> </ul> <li>Vector de distancias: \([0,100 ,30 ,\infty ,\infty]\)</li> <li>Nodo 1 se añade al conjunto de nodos visitados.</li> </ul> <li>Selección del nodo más cercano (Nodo 3):</li> <ul><li>Actualizar las distancias de los vecinos del nodo 3:</li> <ul><li>\(dist[4] = \min(\infty, 30+10) = 40\)</li> <li>\(dist[5] = \min(\infty, 30+60) = 90\)</li> </ul> <li>Vector de distancias: \([0,100 ,30 ,40 ,90]\)</li> <li>Nodo 3 se añade al conjunto de nodos visitados.</li> </ul> <li>Selección del nodo más cercano (Nodo 4):</li> <li>Actualizar las distancias de los vecinos del nodo 4:</li> <ul><li>\(dist[2] = \min(100, 40+15) = 55\)</li> <li>\(dist[5] = \min(90, 40+40) = 80\)</li> </ul> <li>Vector de distancias: \([0,55 ,30 ,40,80]\)</li> <li>Nodo 4 se añade al conjunto de nodos visitados.</li> </ul><div style=""text-align: justify;"">Se continuaría así con los nodos 2 y 5 (no visitados aún); pero el vector de distancias no se va a volver a actualizar. Se concluye que la respuesta es la&nbsp;\(d\).</div></div>"
"<div style=""text-align: justify;"">Se tiene una tabla hash con&nbsp;\(n=23\) índices ocupados y de tamaño \(M=1000\). El factor de carga \(\delta\) será:</div><ol type=""a""><li>-3,7723, es decir \(\ln (n/M)\)</li><li>0,023, es decir \(n/M\)</li><li>0,046, es decir \(2n/M\)</li><li>Ninguna de las otras opciones.</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;""> \(\delta=\frac{\text{celdas ocupadas}}{\text{celdas disponibles}}=\frac{23}{1000}=0.023\)</div></div>"
"<div style=""text-align: justify;"">Dado el siguiente grafo dirigido: Indique cuál sería el valor del vector especial[] en el primer y penúltimo paso del algoritmo de Dijkstra usando como origen el nodo 1:</div><div style=""text-align: justify;""><br></div><div style=""text-align: center;""><img src=""uned-preda_10.png""></div><ol type=""a""><li style=""text-align: justify;"">[50,30,100,10] y [40,30,20,10]</li><li style=""text-align: justify;"">[50,30,100,10] y [35,30,20,10]</li><li style=""text-align: justify;"">[50,30,100,10] y [35,30,100,10]</li><li style=""text-align: justify;"">Ninguna de las otras opciones.</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Nota: las opciones propuestas no tienen en cuenta el nodo inicial, cuya distancia siempre va a ser cero. Por lo tanto, el vector empieza por la distancia del nodo 2. A continuación, se enumeran los primeros pasos que haría el algoritmo contando, en el vector de distancias, el nodo origen:</div><ul><li>Inicialización:</li> <ul><li>Nodo origen: 1.</li> <li>Vector de distancias inicial: \([0,\infty ,\infty ,\infty ,\infty ,\infty ,\infty ]\)</li> <li>Conjunto de nodos visitados: \(\emptyset\).</li> <li>Conjunto de nodos no visitados: {1,2,3,4,5}</li> </ul> <li>Selección del nodo inicial (Nodo 1):</li> <ul><li>Actualizar las distancias de los vecinos del nodo 1:</li> <ul><li>\(dist[2] = \min(\infty, 50) = 50\)</li> <li>\(dist[3] = \min(\infty, 30) = 30\)</li> <li>\(dist[4] = \min(\infty, 100) = 100\)</li> <li>\(dist[5] = \min(\infty, 10) = 10\)</li> </ul> <li>Vector de distancias: \([0,50 ,30 ,100, 10]\)</li> <li>Nodo 1 se añade al conjunto de nodos visitados.</li> </ul> <li>Selección del nodo más cercano (Nodo 5):</li> <ul><li>Actualizar las distancias de los vecinos del nodo 5:</li> <ul><li>\(dist[4] = \min(\infty, 10+10) = 20\)</li> </ul> <li>Vector de distancias: \([0 ,50 ,30 ,20 ,10]\)</li> <li>Nodo 5 se añade al conjunto de nodos visitados.</li> </ul> <li>Selección del nodo más cercano (Nodo 4):</li> <ul><li>Actualizar las distancias de los vecinos del nodo 4:</li> <ul><li>\(dist[2] = \min(50, 20+20) = 40\)</li> <li>\(dist[3] = \min(30, 20+50) = 30\)</li> </ul> <li>Vector de distancias: \([0 ,40 ,30 ,20 ,10]\)</li> <li>Nodo 4 se añade al conjunto de nodos visitados.</li> </ul> <li>Selección del nodo más cercano (Nodo 3):</li> <ul><li>Actualizar las distancias de los vecinos del nodo 3:</li><ul><li>\(dist[2] = \min(40, 30+5) = 35\)</li></ul><li>Vector de distancias:&nbsp;\([0 ,35 ,30 ,20 ,10]\)</li><li>Nodo 3 se añade al conjunto de nodos visitados.</li> </ul> </ul><div style=""text-align: justify;"">Solo faltaría por recorrer el nodo 2; en el que no habría actualizaciones porque no tiene aristas hacia ningún nodo.</div></div>"
"<div style=""text-align: justify;"">¿Cuántos componentes fuertemente conexos existen en el grafo de la siguiente figura?</div><div style=""text-align: justify;""><br></div><div style=""text-align: center;""><img src=""uned-preda_11.png""></div><ol type=""a""><li style=""text-align: justify;"">Uno solo, formado por todo el grafo.</li><li style=""text-align: justify;"">Dos.</li><li style=""text-align: justify;"">Tres.</li><li style=""text-align: justify;"">Más de tres.</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr>Un componente fuertemente conexo (SCC, Strongly Connected Component) es un conjunto de nodos del grafo donde cualquiera puede ser alcanzado por otro nodo del conjunto y viceversa. Un nodo individidual puede ser una SCC.<br><br> Se identifican las siguientes SCC: <ul><li>{b,c,d,e} forman un ciclo.</li><li>{a},{f} y {g} son tres SCC distintas.</li></ul></div>"
"<div style=""text-align: justify;"">Dado el siguiente grafo no dirigido: Indique cuál sería el orden en que se seleccionarían las aristas al aplicar el algoritmo de Kruskal:</div><div style=""text-align: justify;""><br></div><div style=""text-align: center;""><img src=""uned-preda_18.png""></div><ol type=""a""><li style=""text-align: justify;"">Ninguna de las otras opciones.</li><li style=""text-align: justify;"">{{A,C},{C,D},{C,B},{B,E},{D,F}}</li><li style=""text-align: justify;"">{{A,C},{B,E},{C,D},{C,B},{A,F}}</li><li style=""text-align: justify;"">{{A,C},{C,D},{A,B},{B,E},{A,F}}</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">El algoritmo ordena todas las aristas por orden creciente de coste y luego las va seleccionando siempre que dos nodos pertenecientes a dos componentes conexas distintas; es decir, que no se forme un ciclo en el árbol.</div><div style=""text-align: justify;""><br></div><div style=""text-align: justify;"">Por tanto, el orden sería {A,C},{B,E},{C,D},{A,B},{A,F}.</div></div>"
"<div style=""text-align: justify;"">Considérese el vector&nbsp;\( v[1..n] = [8,6,5,5,4,3,2,2] \) cuál de las siguientes opciones es cierta:</div><ol type=""a""><li>El vector \( v \) es un montículo de máximos.</li><li>El vector \( v \) no es un montículo de máximos porque el elemento \( v[5] = 4 \) debe ser flotado.</li><li>El vector \( v \) no es un montículo de máximos porque el elemento \( v[4] = 5 \) debe ser hundido.</li><li>Ninguna de las otras opciones.</li></ol>"	"<div style=""text-align: center;"">a</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Al dibujarlo se ve que es un montículo de máximos porque todos los nodos cumplen ser mayor o igual que cualquiera de sus hijos.</div></div>"
"<div style=""text-align: justify;"">Sea el grafo de la figura: Indique cuál sería el orden en que se seleccionan los nodos del conjunto de candidatos al aplicar el algoritmo de Dijkstra comenzando por el nodo A:</div><div style=""text-align: justify;""><br></div><div style=""text-align: center;""><img src=""uned-preda_12.png""></div><ol type=""a""><li style=""text-align: justify;"">Ninguna de las otras opciones</li><li style=""text-align: justify;"">A C B D E F</li><li style=""text-align: justify;"">A B C D E F</li><li style=""text-align: justify;"">A B D C F E</li></ol>"	"<div style=""text-align: center;"">a</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Simplemente hay que recorrer las aristas por orden creciente de pesos. El orden de selección de los candidatos sería A, C, B, D, F, E.</div></div>"
"<div style=""text-align: justify;"">Dado el grafo de la siguiente figura: indica cuál sería el orden en que se seleccionarían (pasan a estar explorados) los nodos al aplicar el algoritmo de Dijkstra desde el nodo&nbsp;\(A\):</div><br><div style=""text-align: center;""><img src=""uned-preda_13.png""></div><ol type=""a""><li>Ninguna de las otras opciones</li><li>A,F,C,E,B,D</li><li>A,C,D,B,F,E</li><li>A,C,B,F,E,D</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Solo hay que recorrer las aristas por orden creciente de peso. El orden sería A, C, D, B, F, E.</div></div>"
"<div style=""text-align: justify;"">Dadas las matrices:\( A_1 \) (3x5), \( A_2 \) (5x2) y \( A_3 \) (2x3) y \( A_4 \) (3x2) y siendo \( E(i,j) \) el número de operaciones mínimo para resolver la operación \( A_i \cdot A_{i+1} \cdot \ldots \cdot A_j \) mediante programación dinámica, se pide indicar cuál de las siguientes opciones es cierta.</div><ol type=""a""><li>\( E(2,4) = 32 \)</li><li>\( E(2,3) = 15 \)</li><li>\( E(1,3) = 30 \)</li><li>\( E(2,2) = 10 \)</li></ol>"	"<div style=""text-align: center;"">a</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Hay que emplear la técnica de optimización de la multiplicación de cadenas de matrices; esto es un método clásico de programación dinámica. La fórmula que se usa para calcular</div>\[E(i, j) = \min_{i \leq k &lt; j} \left( E(i, k) + E(k+1, j) + p_i \cdot p_{k+1} \cdot p_{j+1} \right)\]donde&nbsp;\(p\) es una lista que contiene las dimensiones de las matrices de tal forma que si una matriz \(A\) tiene dimensiones \(d1 \times d2\) entonces para \(A_{i}\) y \(A_{i+1}\) los valores en \(p\) son \(p_{i}=d1\) y \(p_{i+1}=d2\). El vector \(p\) se obtiene simplemente cogiendo, en orden, los numeros de la dimensión de la primera matriz y luego el segundo número de la dimensión del resto de matrices. De esta forma \(p=[3,5,2,3,2]\). Ahora se calcula \(E(i,j)\) para cada una de las opciones:<h3>Opción a: \(E(2,4)\)</h3>Para calcular \( E(2,4) \) usando las matrices \( A_2, A_3 \), y \( A_4 \):<ul><li>\(E(2,4) = \min(E(2,2) + E(3,4) + 5 \cdot 2 \cdot 2, E(2,3) + E(4,4) + 5 \cdot 3 \cdot 2)\)</li><li>\( E(2,2) = 0 \) (sólo una matriz)</li><li>\(E(3,4) = 2 \cdot 3 \cdot 2 = 12\)</li><li>\(E(2,3) = 5 \cdot 2 \cdot 3 = 30\)</li><li>\(E(2,4) = \min(0 + 12 + 20, 30 + 0 + 30) = \min(32, 60) = 32\)</li></ul><h3>Opción b: \( E(2,3) \)</h3><ul><li>\(E(2,3) = 5\cdot 2 \cdot 3 = 30\) (una sola multiplicación entre \(A_{2}\) y \(A_{3}\)).</li></ul><h3>Opción c: \(E(1,3)\)</h3>Para calcular \(E(1,3)\) con las matrices \(A_{1},A_{2},A_{3}\):<ul><li>\(E(1,3) = \min(E(1,1) + E(2,3) + 3 \cdot 5 \cdot 3, E(1,2) + E(3,3) + 3 \cdot 2 \cdot 3)\)</li><li>\(E(1,1) = E(3,3) = 0 \)</li><li>\(E(1,2) = 3 \cdot 5 \cdot 2 = 30\)</li><li>\(E(1,3) = \min(0 + 30 + 45, 30 + 0 + 18) = \min(75, 48) = 48\)</li></ul><h3>Opción d: \( E(2,2) \)</h3><ul><li>\(E(2,2) = 0\)&nbsp;(no hay multiplicaciones porque es una matriz sola)</li></ul>Por ello, la respuesta correcta es la \(a\).</div>"
"<div style=""text-align: justify;"">Dadas las matrices:&nbsp;\( A_1 \) (2x2), \( A_2 \) (2x5) y \( A_3 \) (5x3) y \( A_4 \) (3x1) siendo \( E(i,j) \) el número de operaciones mínimo para resolver la operación \( A_i \times A_{i+1} \times \ldots \times A_j \) mediante programación dinámica, se pide indicar cuál de las siguientes opciones es cierta.</div><ol type=""a""><li>\( E(2,4) = 25 \)</li><li>\( E(3,4) = 10 \)</li><li>\( E(1,2) = 40 \)</li><li>\( E(2,2) = 10 \)</li></ol>"	"<div style=""text-align: center;"">a</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Hay que emplear la técnica de optimización de la multiplicación de cadenas de matrices; esto es un método clásico de programación dinámica. La fórmula que se usa para calcular</div>\[E(i, j) = \min_{i \leq k &lt; j} \left( E(i, k) + E(k+1, j) + p_i \cdot p_{k+1} \cdot p_{j+1} \right)\]<br><div style=""text-align: justify;"">donde\(p\) es una lista que contiene las dimensiones de las matrices de tal forma que si una matriz \(A\) tiene dimensiones \(d1 \,x\, d2\) entonces para \(A_{i}\) y \(A_{i+1}\) los valores en \(p\) son \(p_{i}=d1\) y \(p_{i+1}=d2\). El vector \(p\) se obtiene simplemente cogiendo, en orden, los numeros de la dimensión de la primera matriz y luego el segundo número de la dimensión del resto de matrices. De esta forma \(p=[2,2,5,3,1]\). Este vector representa las dimensiones de las matrices de manera que cada entrada \(p_{i}\) representa el número de filas de una matriz y \(p_{i+1}\) el número de columnas de la misma matriz, permitiendo calcular el costo de la multiplicación de matrices consecutivas en una secuencia de operaciones. Ahora se calcula \(E(i,j)\) para cada una de las opciones:</div><h3>Opción a: \(E(2,4)\)</h3> Para calcular \( E(2,4) \) usando las matrices \( A_2, A_3 \), y \( A_4 \): <ul> <li>\(E(2,4) = \min(E(2,2) + E(3,4) + 2 \times 5 \times 1, E(2,3) + E(4,4) + 2 \times 3 \times 1)\)</li> <li>Dado que \( E(2,2) = 0 \) (sólo una matriz) y \( E(4,4) = 0 \)</li> <li>\(E(3,4) = 5 \times 3 \times 1 = 15\)(una sola multiplicación)</li> <li>\(E(2,3) = 2 \times 5 \times 3 = 30\)(una sola multiplicación)</li> <li>Entonces\(E(2,4) = \min(0 + 15 + 10, 30 + 0 + 6) = \min(25, 36) = 25\)</li> </ul> <h3>Opción b: \( E(3,4) \)</h3> <ul> <li>Como se calculó antes,\(E(3,4) = 15\)</li> </ul> <h3>Opción c: \(E(1,2)\)</h3> <ul> <li>Para calcular \( E(1,2) \):\(E(1,2) = 2 \times 2 \times 5 = 20\)(una sola multiplicación)</li> </ul> <h3>Opción d: \( E(2,2) \)</h3> <ul> <li>\(E(2,2) = 0\)(no hay multiplicaciones porque es una matriz sola)</li> </ul> Por ello, la respuesta correcta es la \(a\).</div>"
"<div style=""text-align: justify;"">Aplicando el algoritmo de Dijkstra al grafo con conjunto de vértices&nbsp;\({1,2,\dots, 8}\) y aristas con pesos (entre paréntesis) representadas por lista de adyacencia:</div><ul><li>\(1 \rightarrow 2(4), 3(10), 4(2), 6(8) \)</li><li>\(2 \rightarrow 4(4) \)</li><li>\(3 \rightarrow 6(1), 8(10) \)</li><li>\(4 \rightarrow 5(2), 6(1), 7(5) \)</li><li>\(5 \rightarrow 3(5), 6(1) \)</li><li>\(6 \rightarrow 3(9) \)</li><li>\(7 \rightarrow 1(7) \)</li><li>\(8 \rightarrow 3(2), 4(3), 7(2) \)</li></ul><div style=""text-align: justify;"">Cuál de las siguientes NO es un valor correcto para el vector “Especial” generado por el algoritmo de Dijkstra a lo largo de las iteraciones, representando en cada iteración la distancia mínima hasta el momento entre los vértices 1 e i:</div><ol type=""a""><li>\(D = [4,10,2,4,3,7,19]\)<br></li><li>\(D = [4,10,2,4,3,7,\infty]\)</li><li>\(D = [4,10,2,\infty,8,\infty,\infty]\)</li><li>\(D = [4,9,2,4,3,7,\infty]\)</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">La representación gráfica del grafo es la siguiente:&nbsp;</div><div style=""text-align: justify;""><br></div><div style=""text-align: center;""><img src=""uned-preda_20.png""></div><div style=""text-align: justify;"">El objetivo es identificar aquel vector ""Especial"" que jamás pueda ser generado por el algoritmo de Dijkstra en cualquier iteración respecto este grafo.</div><div style=""text-align: justify;"">En este sentido hay que tener en cuenta el nodo recorrido en los pasos iniciales del algoritmo. Después del primer nodo, se irá al cuarto porque es el más cercano; éste tiene acceso a los nodos 5, 6 y 7 por lo que si se conoce el camino (aunque no sea mínimo todavía) al nodo 4, también se tiene que conocer el de estos 3 nodos porque por cómo funciona el algoritmo, en cada iteración registra el camino al nodo actual respecto al inicial, y el de los nodos a los que sale.</div><div style=""text-align: justify;"">Se puede ver que en la opción&nbsp;\(c\) se conoce una distancia al nodo 4 pero no la del 6, por lo que se concluye que la respuesta correcta es esa.</div><div style=""text-align: justify;"">\(c\) se conoce una distancia al nodo 4 pero no la del 6, por lo que se concluye que la respuesta correcta es esa.</div>\(c\) se conoce una distancia al nodo 4 pero no la del 6, por lo que se concluye que la respuesta correcta es esa.<br></div>"
"<div style=""text-align: justify;"">Dado el vector&nbsp;\( M= [5, 6, 12, 1, 7, 9, 3, 7, 1, 11, 3, 2, 8, 6, 5, 9] \) al que aplicamos el algoritmo de ordenación Quicksort tomando como pivotes los valores \( M[0] \) y para una ordenación de menor a mayor. Se pide contestar la opción verdadera:</div><br><ol type=""a""><li>La primera recursión del algoritmo genera dos llamadas a quicksort con argumentos [1 3 6 7 7 9 12] y [1 2 3 5 6 8 9 11] con pivote \( M[0] = 5 \).</li><li>La primera recursión del algoritmo genera dos llamadas a quicksort con argumentos [6 12 1 7 9 3 7] y [1 11 3 2 8 6 5 9] con pivote \( M[0] = 5 \).</li><li>La primera recursión del algoritmo genera dos llamadas a quicksort con argumentos [3 5 2 1 3 1 ] y [7 9 11 7 12 8 6 6 9 ] con pivote \( M[0] = 5 \).</li><li>La primera recursión del algoritmo genera dos llamadas a quicksort con argumentos [1 1 2 3 3 5] y [6 6 7 7 8 9 9 11 12] con pivote \( M[0] = 5 \).</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr>Lo que se hace al pivotar es dividir el vector de partida en dos mitades: una; con elementos menores al pivote, y otra; con elementos mayores al pivote. Sabiendo esto podemos descartar las opciones \(a\) y \(b\). Entre las opciones \(c\) y \(d\) se puede ver como en la última ambos vectores están ordenados de forma creciente diciendo que eso es el resultado en la primera recursión, lo cual es incorrecto porque ese es el resultado de la finalización del algoritmo; que en este caso va a requerir más de una recursión. La respuesta correcta es la \(c\).</div>"
"<div style=""text-align: justify;""><div style=""text-align: justify;"">Sea un grafo denso no dirigido representado con la siguiente matriz de adyacencia, en la que puede haber pesos de valor 0:</div><div style=""text-align: justify;""><br></div><div align=""center""><table border=""1""><tbody><tr><td></td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td></tr><tr><td>1</td><td>-</td><td>2</td><td>3</td><td>4</td><td>5</td><td>0</td><td>1</td><td>2</td></tr><tr><td>2</td><td>-</td><td>-</td><td>0</td><td>2</td><td>4</td><td>0</td><td>2</td><td>4</td></tr><tr><td>3</td><td>-</td><td>-</td><td>-</td><td>0</td><td>3</td><td>0</td><td>3</td><td>0</td></tr><tr><td>4</td><td>-</td><td>-</td><td>-</td><td>-</td><td>2</td><td>0</td><td>4</td><td>2</td></tr><tr><td>5</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>0</td><td>5</td><td>4</td></tr><tr><td>6</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>0</td><td>0</td></tr><tr><td>7</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>2</td></tr><tr><td>8</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table></div><br><div style=""text-align: justify;"">Si se utiliza el algoritmo de Prim para calcular un árbol de recubrimiento mínimo tomando como raíz del árbol el nodo 1, indica cuál de las siguientes secuencias de aristas representa el orden en el que las selecciona el algoritmo de Prim como integrantes del árbol de recubrimiento mínimo:</div><ol type=""a""><li style=""text-align: justify;"">{1,6},{1,2},{2,3},{4,6},{6,5},{6,8},{6,7}.</li><li style=""text-align: justify;"">{1,6},{1,7},{6,2},{6,3},{4,6},{6,5},{6,8}.</li><li style=""text-align: justify;"">{1,6},{6,2},{2,3},{3,8},{4,6},{6,5},{6,7}.</li><li style=""text-align: justify;"">{1,7},{1,6},{6,3},{6,2},{4,6},{6,5},{6,8}.</li></ol></div>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Las aristas se van recorriendo en orden creciente de costes, por lo que la primera arista siempre será {1,6}; podemos descartar la opción&nbsp;\(d\). El nodo 6 tiene acceso al resto de nodos del grafo a través de aristas de coste 0, luego sabemos que en la segunda arista siempre intervendrá el nodo 6. Debido a esto podemos descartar las opciones \(a\) y \(b\).</div></div>"
"<div style=""text-align: justify;""><div>Sea un grafo no dirigido representado con la siguiente matriz de adyacencia:&nbsp;</div><div><br></div><div align=""center""><table border=""1"" style=""text-align: justify;""><tbody><tr><td></td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>1</td><td>-</td><td>10</td><td>-</td><td>-</td><td>6</td><td>-</td><td>-</td></tr><tr><td>2</td><td>-</td><td>-</td><td>5</td><td>2</td><td>-</td><td>-</td><td>-</td></tr><tr><td>3</td><td>-</td><td>-</td><td>-</td><td>4</td><td>-</td><td>-</td><td>-</td></tr><tr><td>4</td><td>-</td><td>-</td><td>-</td><td>-</td><td>3</td><td>-</td><td>-</td></tr><tr><td>5</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>9</td><td>1</td></tr><tr><td>6</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>8</td></tr><tr><td>7</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><div style=""text-align: justify;""><br></div></div><div>Si se utiliza el algoritmo de Kruskal para calcular un árbol de recubrimiento mínimo, indica cuál de las siguientes secuencias de aristas (que incluye las rechazadas) representa el orden en el que las evalúa el algoritmo:</div><ol type=""a""><li style=""text-align: justify;"">{1,5},{5,7},{6,7},{4,6},{2,4},{4,3}.</li><li style=""text-align: justify;"">{5,7},{1,5},{6,7},{4,6},{2,4},{4,3}.</li><li style=""text-align: justify;"">{5,7},{2,4},{4,6},{3,4},{1,5},{6,7},{5,6}.</li><li style=""text-align: justify;"">{5,7},{2,4},{4,6},{3,4},{2,3},{1,5},{6,7}.</li></ol></div>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr>Si incluye las rechazadas, la solución corresponde a ordenar las aristas por orden creciente de coste.</div>"
"<div style=""text-align: justify;"">Dado el siguiente grafo, indique cuál sería el orden en que se seleccionarían los nodos (pasan a estar explorados) al aplicar el algoritmo de Dijkstra para encontrar todos los caminos de menor coste desde el nodo 1:</div><div style=""text-align: justify;""><br></div><div style=""text-align: center;""><img src=""uned-preda_14.png""></div><ol type=""a""><li style=""text-align: justify;"">{1, 2, 3, 4, 5}</li><li style=""text-align: justify;"">{1, 4, 3, 5, 2}</li><li style=""text-align: justify;"">{1, 2, 4, 3, 5}</li><li style=""text-align: justify;"">Ninguna de las otras opciones</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Se debe de seleccionar en cada paso la arista de menor coste disponible en el árbol que se lleva construido hasta el momento.</div></div>"
"<div style=""text-align: justify;"">Considérese el vector&nbsp;\( [10,6,3,5,2,3,2] \) que representa un montículo. ¿Cuál sería la representación resultante de insertar (función \(Insertar\) del texto base) en este montículo el valor 6 usando la función flotar?</div><ol type=""a""><li>[10,6,5,3,6,2,2,3]</li><li>[10,6,6,3,3,2,5,2]</li><li>[10,6,3,6,2,3,2,5]</li><li>Ninguna de las otras opciones.</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr>Nada que comentar.</div>"
"<div style=""text-align: justify;"">Sea el grafo dirigido de la siguiente figura:&nbsp;</div><div style=""text-align: justify;""><br></div><div style=""text-align: center;""><img src=""uned-preda_15.png""></div><div style=""text-align: justify;""><br></div><div style=""text-align: justify;"">¿Cuál de las siguientes afirmaciones es cierta?</div><ol type=""a""><li style=""text-align: justify;""><div style=""text-align: justify;"">El nodo&nbsp;\(E\) es un punto de articulación.</div></li><li style=""text-align: justify;""><div style=""text-align: justify;"">Un posible recorrido en anchura visitaría los nodos en orden&nbsp;\(\{D,B,C,E,F,A,G\}\), si se toma el nodo \(D\) como nodo de partida.</div></li><li style=""text-align: justify;""><div style=""text-align: justify;"">Un posible recorrido en profundidad visitaría los nodos en orden&nbsp;\(\{D,B,E,A,G,C,F\}\), si se toma el nodo \(D\) como nodo de partida.</div></li><li style=""text-align: justify;"">Todas las afirmaciones son ciertas.</li></ol>"	"<div style=""text-align: center;"">d</div><div style=""text-align: justify;""><hr>Nada que comentar.</div>"
"<div style=""text-align: justify;"">Un servidor tiene que atender tres clientes que llegan todos juntos al sistema. El tiempo que requerirá dar servicio a cada cliente es conocido, siendo&nbsp;\(t_1=5\), \(t_2=10\) y \(t_3=3\). El objetivo es minimizar el tiempo medio de estancia de los clientes en el sistema. Se quiere implementar un algoritmo voraz que construya la secuencia ordenada óptima de servicio a los distintos clientes. Según este algoritmo, el tiempo mínimo de estancia en el sistema del conjunto de clientes es:</div><ol type=""a""><li>34</li><li>26</li><li>29</li><li>31</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">El problema es análogo al de ""minimización del tiempo en el sistema"" y consiste en ordenar el tiempo de estancia de los clientes de forma creciente. Sea el tiempo medio de estancia del cliente \(i\) el tiempo y \(n\) el número de clientes, el tiempo total de estancia de los clientes \(T\) es\[T = e_1 + (e_1 + e_2) + (e_1 + e_2 + e_3) + \cdots = ne_1 + (n - 1)e_2 + (n - 2)e_3 + \cdots \]\[= \sum_{k=1}^{n} (n - k + 1)e_k\]Para el caso actual \(n=3\) y la secuencia de clientes organizados {\(t_{3},t_{1},t_{2}\)}:&nbsp;</div>\[(3-1+1)\cdot3+(3-2+1)\cdot5+(3-3+1)\cdot10 = 29\]</div>"
"<div style=""text-align: justify;"">Sea el problema de la devolución de cambio con monedas de valores 1, 6 y 10 solucionado con programación dinámica para pagar una cantidad de 12 unidades. Identifica cuál de las siguientes respuestas correspondería al contenido de la tabla de resultados parciales de cantidades en la fila correspondiente a la moneda de valor 6, si dichas monedas se consideran por orden creciente de valores:</div><ol type=""a""><li style=""text-align: justify;"">0 1 2 3 4 5 6 2 3 4 5 6 7</li><li style=""text-align: justify;"">0 1 2 3 4 5 6 2 3 4 5 6 3</li><li style=""text-align: justify;"">0 1 2 3 4 5 1 2 3 4 5 6 2</li><li style=""text-align: justify;"">Ninguna de las otras opciones</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">La fila más superior de la tabla debe tener cada una de las cantidades a pagar numeradas de 1 a 12 crecientemente. La columna más a la izquierda corresponde a cada tipo de moneda también de forma creciente. En las celdas se pone el número mínimo de monedas para pagar la cantidad de la columna actual, usando la moneda de la fila actual y la de las anteriores.&nbsp;</div></div>"
"<div style=""text-align: justify;"">Sea el problema de la mochila en su versión de objetos no fraccionables solucionado mediante programación dinámica. Suponga que se dispone de 3 objetos con pesos&nbsp;\(\{9, 6, 5\}\) y que aportan unos beneficios de \(\{38, 40, 24\}\), respectivamente. Suponga también que dispone de una mochila con una capacidad máxima de 15. Considere que, al aplicar el algoritmo, los objetos se consideran en el orden dado en el enunciado \(\{9,6, 5\}\). Indique qué afirmación es cierta:</div><ol type=""a""><li>La tabla de resultados parciales en la fila correspondiente al objeto de peso 5 es: 0 0 0 0 0 24 40 40 40 40 40 64 64 64 64 78</li><li>La tabla de resultados parciales en la fila correspondiente al objeto de peso 6 es: 0 0 0 0 0 0 24 24 24 40 40 40 64 64 64 78</li><li>El beneficio máximo final obtenido es 80.</li><li>El problema propuesto se resuelve más eficientemente utilizando un enfoque voraz.</li></ol>"	"<div style=""text-align: center;"">a</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Podemos descartar la&nbsp;\(c\); porque cuando los objetos NO son fraccionables no puede resolverse eficientemente con un esquema voraz, y la \(d\); porque el máximo beneficio es de usar el primer y segundo objeto, cuyo peso total sería de 15 (máximo de la mochila) y beneficio 78.</div><br>La \(b\) es falsa porque, dado que se dice de considerar los objetos en el orden dado en el enunciado, la fila correspondiente al objeto de peso 6 no tiene acceso al objeto de peso 5 por lo que no es posible que ninguno de sus valores sera de 24; el valor del objeto de peso 5.<br></div>"
"<div style=""text-align: justify;"">Dado el siguiente montículo de máximos, ¿Cuál de los siguientes vectores lo representa de forma correcta?</div><div style=""text-align: justify;""><br></div><div style=""text-align: center;""><img src=""uned-preda_16.png""></div><ol type=""a""><li style=""text-align: justify;"">23, 15, 21, 11, 6, 3, 5, 4, 14, 9</li><li style=""text-align: justify;"">No es un montículo de máximos, sino de mínimos</li><li style=""text-align: justify;"">23, 15, 21, 11, 6, 14, 9, 3, 5, 4</li><li style=""text-align: justify;"">23, 15, 11, 3, 5, 6, 4, 21, 14, 9</li></ol>"	"<div style=""text-align: center;"">c</div><div style=""text-align: justify;""><hr>El vector se corresponde con un recorrido en altura de izquierda a derecha del árbol.</div>"
"<div style=""text-align: justify;"">Considérese el vector [7, 10, 5, 2, 20, 15, 1, 5]. Los vectores argumento de la primera invocación recursiva del algoritmo de quicksort, cuando se toma el elemento 7 de la primera posición como pivote, son:</div><ol type=""a""><li style=""text-align: justify;"">Ninguna de las otras opciones</li><li style=""text-align: justify;"">[5, 2, 5, 1] y [10, 20, 15]</li><li style=""text-align: justify;"">[5, 2, 5, 1] y [15, 20, 10]</li><li style=""text-align: justify;"">[1, 5, 5, 2] y [15, 20, 10]</li></ol>"	"<div style=""text-align: center;"">a</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Tenemos dos punteros: uno que empieza desde el principio del vector; buscando un elemento mayor que el pivote, y otro al final; buscando un elemento menor. La secuencia de intercambios sería:</div><ol><li style=""text-align: justify;""><div style=""text-align: justify;""> \(v[1]=10 \text{ con } v[7]=5\)</div></li><li style=""text-align: justify;""><div style=""text-align: justify;""> \(v[4]=20 \text{ con } v[6]=1\)</div></li></ol><div style=""text-align: justify;"">Y esto resultaría en los vectores [5,5,2,1] y [15,20,10].</div></div>"
"<div style=""text-align: justify;"">Considérese el vector&nbsp;\(v = [3, 6, 4, 7, 9, 2, 5]\). ¿Cuál de las siguientes opciones es cierta?</div><ol type=""a""><li>Ninguna de las otras opciones</li><li>\(v\) sería un montículo de mínimos si se flotara el elemento de valor 2.</li><li>El vector \(v\) es un montículo de mínimos.</li><li>\(v\) sería un montículo de mínimos si se hundiera el elemento de valor 6.</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr>Nada que comentar.</div>"
"<div style=""text-align: justify;"">Considérese el vector&nbsp;\([15, 7, 10, 5, 3, 8, 2]\) que representa un montículo de máximos. ¿Cuál sería la representación resultante de insertar en este montículo el valor 11 usando la función flotar?</div><ol type=""a""><li>\([15, 11, 10, 7, 3, 8, 2, 5]\)</li><li>\([15, 11, 10, 7, 5, 8, 2, 3]\)</li><li>\([15, 10, 11, 7, 3, 8, 2, 5]\)</li><li>Ninguna de las otras opciones</li></ol>"	"<div style=""text-align: center;"">a</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">El 11 se inserta como hijo derecho del nodo 5. Al flotarlo, primero se intercambiará por el nodo 5 y luego por el 7. El resultado es la opción&nbsp;\(a\).</div></div>"
"<div style=""text-align: justify;"">Se dispone de un vector, V, que almacena números enteros en orden estrictamente creciente, y se desea averiguar si existe algún elemento que cumpla V[i]=i. ¿Cuál sería la estrategia más eficiente para resolver el problema?</div><ol type=""a""><li style=""text-align: justify;"">Ninguna de las otras opciones es aplicable al problema</li><li style=""text-align: justify;"">Divide y vencerás.</li><li style=""text-align: justify;"">Algoritmo voraz.</li><li style=""text-align: justify;"">Programación dinámica.</li></ol>"	"<div style=""text-align: center;"">b</div><div style=""text-align: justify;""><hr><div style=""text-align: justify;"">Realizando una búsqueda binaria se puede hacer con un coste&nbsp;\(O(\log{n})\) respecto el tamaño de \(V\).</div></div>"
